#+title: Average GNU/Emacs Enjoyer's config

#+options: toc:nil
#+property: header-args:elisp :results silent

For a long time, I refused to write a literate emacs config.  The main reason
was that, I thought that it was needed only for novices, who do not know any
/e-lisp/.  An /e-lisp/ expert does not need any code explanations and I don't
really care about *GNU/Emacs* novices.

Why I changed my mind?  Because, /org-mode/, besides code comments, provides a
good *structure* for your config.  Structure is important.  I could have it by
splitting the file into multiple ones, but I like the idea of having everything
in one place for *GNU/Emacs* config.  In fact, previously, I was using
~outline-minor-mode~.  Also, I wanted to write something.

So, here we go, my *GNU/Emacs* config.

* Early Init
:properties:
:header-args:elisp: :tangle early-init.el
:end:

First thing first.  *GNU/Emacs* now has an /early-init.el/ file.  It is a
special file that is loaded before the package system and GUI is initialized.
It is a good place to fine-tune the startup performance.

#+begin_src elisp
;; -*- lexical-binding: t; -*-
#+end_src

** Garbage Collector
The big idea here is to make the garbage collector threshold high as possible
during the loading of /init.el/ and restore it after.  By doing this,
*GNU/Emacs* would have minimal number of garbage collections and, as a result,
startup will be faster.  I'm not claiming to be a low-level *GNU/Emacs* expert,
feel free to correct me.

#+begin_src elisp
(let ((old-threshold gc-cons-threshold))
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold old-threshold)))
  (setq gc-cons-threshold most-positive-fixnum))
#+end_src

** Startup time
This is a nice little snippet of code, that helps you stay in a good shape.  If
your startup time is bigger than the usual, you fucked something up.  Also, it
enhances your ability to *FLEX* on /e-lisp/ peasants.

#+begin_src elisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "Emacs ready in %s with %d garbage collections." (emacs-init-time) gcs-done)))
#+end_src

** Rest
An import of /xdg/ library.  If you are still not using [[https://wiki.archlinux.org/title/XDG_Base_Directory][XDG]], you might consider
+killing yourself+ start using it.  It provides a good *STRUCTURE™* to your
hamster (from rus: hamster -> хомяк -> homyak -> home).

#+begin_src elisp
(require 'xdg)
#+end_src

* Init
:properties:
:header-args:elisp: :tangle init.el
:end:

Here is the juicy part of my *GNU/Emacs* config.  We start by writing a header.

#+begin_src elisp
;; -*- lexical-binding: t; -*-

(define-prefix-command 'region-commands-map)
(define-prefix-command 'load-command-map)
(define-prefix-command 'ediff-command-map)
#+end_src

** Packages
/Based on a true story/

"Bruh, what is this, you are not using /use-package/, it's 2k20, bruh" some
*GNU/Emacs* peasant said.

"Bruh, you are using /custom/, it is a tool from the 90s" ejaculated another
one.

They hated Jesus, because he told them the truth.

--

For real, though.  I've used four different ways of organizing packages in my
config.  First, it was plain /e-lisp/ code, without much *STRUCTURE™*.  I loved
the freedom aspect of it.

Then, came the /use-package/ era.  It provided a lot of *STRUCTURE™*, at the
cost of freedom.  Also, it hided away many things and provided a lot of
questionable features by defaults.  For example: it removed ~-hook~ from hooks
or autoloaded everything.  Autoloading is a good thing, but, you, almost, never
have to do it manually.  Most packages have good autoload cookies by default.
The only situation in which you might need autoloads, is when you write your own
files in *GNU/Emacs* config directory (which are not processed by /package.el/).
Even there you can generate autoload cookies.  Also, /use-package/ has an
enormous and complicated code base.

So, I switched to /leaf/.  It fixed many problems that I had with /use-package/.
Smaller code base, better defaults etc.  But, I still felt that something was
wrong with this approach.  At the time, I also started using [[../overlays/emacs.nix][Nix]] to manage my
*GNU/Emacs* packages, so the feeling of /use-package/ (or /leaf/) being
redundant grew even bigger.

Suddenly, one Fried Zucchini told me: "Psst, hey kid... you want some
/custom.el/?".  It was a bizarre experience, but armed with my +sword+
*GNU/Emacs* /info/ manual, I started researching this topic.  After a lot of
research (and [[https://www.youtube.com/watch?v=UHk3FbieW0w][Protesilaos Stavrou's enlightening video]] about
~outline-minor-mode~) I, finally, decided to ditch /leaf/ and switched to
/custom/ config with ~outline~ as a structure.  Why ~outline~?  Well, I learned
a good lesson from /use-package/.  Organizing config around packages is a good
idea.  So, I needed something to delimit portions of code and assign them to
different packages.

What a good feeling of freedom it was.  I liked /custom/ because it removed all
the rare-changing variables from /init.el/ and facilitated search and
modification of them.  *GNU/Emacs* GUI is well integrated with keyboard
shortcuts.  It does not require you to use mouse.

Now, it is time to grow up and use /org-mode/.

Every header corresponds to some package name (~package-name~ -> /Package
Name/).  All headers are sorted alphabetically.

*** Abbrev
Good old abbrevs.  One of the oldest packages out there.  This package lets you
define abbreviations for words and can trigger their expansion after inserting a
space.  You can use it just for anything:

- abbreviations (gvt -> government)
- shell aliases (ls -> ls --color=always)
- poor man's spell checker (helol -> hello)
- code templates (fn -> function() {})
- whatever your imagination tells you

You can see a list of my abbrevs [[abbrev_defs][here]].  Of course, I have not defined them all
by myself.  There is a good list of abbrevs [[https://www.emacswiki.org/emacs/autocorrection_abbrev_defs][here]].

#+begin_src elisp
(add-hook 'js-mode-hook 'abbrev-mode)
#+end_src

*** Align
#+begin_src elisp
(define-key region-commands-map "\C-a" 'align-regexp)
#+end_src

*** Auto Insert
:PROPERTIES:
:header-args: :mkdirp yes
:END:

Auto Insert supports files as templates if you give it a directory.

**** Nix Shell
Let's write some reproducible /nix-shell/ templates.

***** Common Lisp
This ~shell.nix~ configures local environment *Common Lisp*.  It automaticall
downloads quicklisp in project local directory and patches various
implementations to use it by default.

#+begin_src nix :tangle auto-insert/shell-common-lisp.nix
let
  pkgs = import <nixpkgs> {};

  PROJECT_ROOT = builtins.toString ./.;
  QUICKLISP_DIR = "${PROJECT_ROOT}/.quicklisp";

  quicklisp-lisp = builtins.fetchurl https://beta.quicklisp.org/quicklisp.lisp;
  quickstart = pkgs.writeShellScriptBin "quickstart" ''
    ${pkgs.sbcl}/bin/sbcl \
        --non-interactive \
        --no-userinit \
        --load "${quicklisp-lisp}" \
        --eval "(quicklisp-quickstart:install :path #P\"${QUICKLISP_DIR}/\")"
  '';

  init-lisp = pkgs.writeText "init.lisp" ''
    #-quicklisp
    (let ((quicklisp-init #P"${QUICKLISP_DIR}/setup.lisp"))
      (when (probe-file quicklisp-init)
        (load quicklisp-init)))
  '';

  make-implementation = name: pkg: flags: pkgs.symlinkJoin {
    name = name;
    paths = [ pkg ];
    nativeBuildInputs = [ pkgs.makeWrapper ];
    postBuild = ''
      wrapProgram $out/bin/${name} --add-flags '${flags}'
    '';
  };

  sbcl = make-implementation "sbcl" pkgs.sbcl "--userinit ${init-lisp}";
  ecl = make-implementation "ecl" pkgs.ecl "--norc --load ${init-lisp}";
  ccl = make-implementation "ccl" pkgs.ccl "--no-init --load ${init-lisp}";
  clisp = make-implementation "clisp" pkgs.clisp "-norc -i ${init-lisp}";
  abcl = make-implementation "abcl" pkgs.abcl "--noinit --load ${init-lisp}";

in pkgs.mkShell {
  CL_SOURCE_REGISTRY="${PROJECT_ROOT}:";
  ASDF_OUTPUT_TRANSLATIONS = ''
    (:output-translations
     :ignore-inherited-configuration
     (t ("${PROJECT_ROOT}" ".common-lisp" :implementation)))
  '';
  buildInputs =  [ quickstart sbcl ecl ccl clisp abcl ];
  shellHook = ''
    [ -d "${QUICKLISP_DIR}" ] || quickstart
  '';
}
#+end_src

**** Gitignore

***** Common Lisp
#+begin_src text :tangle auto-insert/gitignore-common-lisp
*.fasl
*.dx32fsl
*.dx64fsl
*.lx32fsl
*.lx64fsl
*.x86f
*~
.#*
.quicklisp
.common-lisp
#+end_src

*** [[https://github.com/abo-abo/avy][Avy]]
Gotta move fast.  A must-have package to quickly jump to places in a buffer.
Instead of prefixes, I just highlight every /symbol/.  It can be slower with a
lot of short /symbols/ in a buffer, but it works fine most of the time.

#+begin_src elisp
(define-key global-map "\M-z" 'avy-goto-word-0)
(define-key goto-map "\M-g" 'avy-goto-line)
#+end_src

*** Browse Url
Sometimes, I need to browse a url (at point or by inserting it into the
minibuffer).

#+begin_src elisp
(define-key ctl-x-map "B" 'browse-url)

(with-eval-after-load 'browse-url
  (defun browse-url-choices (url &rest args)
    (let* ((answers '(("firefox" ?f "Open in firefox" browse-url-firefox)
                      ("eww" ?e "Open in eww" eww-browse-url)
                      ("brave" ?b "Open in brave" browse-url-generic)
                      ("ytdli" ?y "Download with ytdli"
                       (lambda (url &rest _args)
                         (call-process "ytdli" nil 0 nil url)))
                      ("mpvi" ?m "Open in mpvi"
                       (lambda (url &rest _args)
                         (call-process "setsid" nil 0 nil "-f" "mpvi" url)))))
           (read-answer-short t)
           (answer (read-answer (concat url " ") answers)))
      (apply (nth 3 (assoc answer answers)) url args))))
#+end_src

*** [[https://github.com/jwiegley/emacs-async/blob/master/async-bytecomp.el][Bytecomp Async]]
I don't like to wait for byte-compilation.

#+begin_src elisp
(declare-function async-bytecomp-package-mode "async-bytecomp" (&optional arg))
(with-eval-after-load 'bytecomp (async-bytecomp-package-mode))
#+end_src

*** [[https://github.com/kwrooijen/cargo.el][Cargo]]
Nice cargo commands, for /state-of-the-art/ experience of *Rust* compilation.

#+begin_src elisp
(add-hook 'rust-mode-hook 'cargo-minor-mode)
#+end_src

*** Comint
In /comint/ we trust.  I like how easy it is to create custom repls with this
package.

#+begin_src elisp
(define-key mode-specific-map "c" 'comint-run)

(add-hook 'comint-output-filter-functions 'comint-strip-ctrl-m)
(add-hook 'comint-output-filter-functions 'comint-truncate-buffer)
(add-hook 'comint-output-filter-functions 'comint-osc-process-output)

(define-advice comint-run (:override (name command) shell)
  (declare (interactive-only make-comint))
  (interactive
   (let* ((command (read-shell-command "Command: "))
          (name (car (split-string-shell-command command)))
          (name (if (not current-prefix-arg) name
                  (read-string (format-prompt "Name" name) nil nil name))))
     (list name command)))
  (switch-to-buffer
   (make-comint name shell-file-name nil shell-command-switch command))
  (run-hooks (intern-soft (concat "comint-" name "-hook"))))
#+end_src

*** Compile
We finally have nice things in 2k22.

#+begin_src elisp
(with-eval-after-load 'compile
  (define-key compilation-shell-minor-mode-map "\C-c\C-g" 'recompile)
  (add-hook 'compilation-filter-hook 'ansi-color-compilation-filter))
#+end_src

*** [[https://github.com/minad/consult][Consult]]
This is a game changer.  A package that strives to be a
completion-framework-agnostic replacement for [[https://github.com/abo-abo/swiper][counsel]].

#+begin_src elisp
(defvar kmacro-keymap)
(define-key global-map "\M-H" 'consult-history)
(define-key goto-map "o" 'consult-outline)
(define-key goto-map "i" 'consult-imenu)
(define-key goto-map "E" 'consult-compile-error)
(define-key goto-map "F" 'consult-flymake)
(define-key project-prefix-map "i" 'consult-project-imenu)
(define-key kmacro-keymap "c" 'consult-kmacro)
(with-eval-after-load 'consult
  (add-hook 'completion-list-mode-hook 'consult-preview-at-point-mode))
#+end_src

*** Css Mode
/Css-mode/ has a good command to lookup documentation.

#+begin_src elisp
(defvar css-mode-map)
(with-eval-after-load 'css-mode (define-key css-mode-map "\C-cm" 'css-lookup-symbol))
#+end_src

*** Custom
By default, /custom/ does not have any keybindings.  This is a shame, since they
are a must-have for it.

#+begin_src elisp
(defvar cus-edit-map (make-sparse-keymap))
(define-key cus-edit-map "v" 'customize-option)
(define-key cus-edit-map "g" 'customize-group)
(define-key cus-edit-map "f" 'customize-face)
(define-key cus-edit-map "s" 'customize-saved)
(define-key cus-edit-map "u" 'customize-unsaved)
(define-key ctl-x-map "c" cus-edit-map)
#+end_src

*** [[https://github.com/xFA25E/cyrillic-dvorak-im][Cyrillic Dvorak Im]]
A package, copied from EmacsWiki (bless them), that provides an input-method for
russian keybord using dvorak.

#+begin_src elisp
(require 'cyrillic-dvorak-im)
#+end_src

*** Dictionary
New addition to *GNU/Emacs* in 2k22.  It can search [[https://datatracker.ietf.org/doc/html/rfc2229][dict]] servers.  I
predominantly use /SDCV/ with tons of [[../overlays/stardicts.nix][offline dictionaries]], but maybe I can find
use for this package.

#+begin_src elisp
(define-key mode-specific-map "oT" 'dictionary-search)
#+end_src

*** Dired
Another favorite package of mine.  I can't imagine browsing my file-system
without it anymore.

#+begin_src elisp
(defvar dired-mode-map)
(defvar dired-compress-file-suffixes)
(defvar dired-compress-files-alist)
(defvar dired-log-buffer)
(declare-function dired-log "dired" (log &rest args))
(declare-function dired-get-marked-files "dired" (&optional localp arg filter distinguish-one-marked error))
#+end_src

**** Dired X
Same as the above, but has one of my favorite /dired/ features:
~dired-guess-shell-alist-user~.

#+begin_src elisp
(with-eval-after-load 'dired (require 'dired-x))
#+end_src

**** Dired Aux
A package with many useful functions.

#+begin_src elisp
(declare-function dired-do-compress-to@async "dired-aux" (&optional arg))
(declare-function dired-relist-file "dired-aux" (file))
(with-eval-after-load 'dired-aux
  (define-key dired-mode-map "\M-+" 'dired-create-empty-file)
  (add-to-list 'dired-compress-file-suffixes
               (list (rx ".tar.bz2" eos) "" "bunzip2 -dc %i | tar -xf -"))

  (defun dired-do-compress-to@async (&optional arg)
    (interactive "P")
    (require 'format-spec)
    (let* ((in-files (dired-get-marked-files nil arg nil nil t))
           (out-file (expand-file-name (read-file-name "Compress to: ")))
           (rule (cl-find-if (lambda (x) (string-match-p (car x) out-file))
                             dired-compress-files-alist)))
      (cond
       ((not rule)
        (error "No compression rule found for %s, see `dired-compress-files-alist'" out-file))
       ((and (file-exists-p out-file)
             (not (y-or-n-p (format "%s exists, overwrite?" (abbreviate-file-name out-file)))))
        (message "Compression aborted"))
       (t
        (let* ((in-count 0)
               (proc-name (concat "compress " out-file))
               (qout-file (shell-quote-argument out-file))
               (qin-files (mapconcat (lambda (file) (cl-incf in-count)
                                       (shell-quote-argument (file-name-nondirectory file)))
                                     in-files " "))
               (cmd (format-spec (cdr rule) `((?\o . ,qout-file) (?\i . ,qin-files))))
               (buffer (generate-new-buffer "*dired-async-do-compress-to*"))
               (proc (start-file-process-shell-command proc-name buffer cmd))
               (sentinel
                (lambda (process event)
                  (pcase event
                    ("finished\n"
                     (message "Compressed %d file%s to %s" in-count
                              (ngettext "" "s" in-count)
                              (file-name-nondirectory out-file))
                     (kill-buffer (process-buffer process))
                     (dired-relist-file out-file))
                    ((rx bos "exited abnormally with code")
                     (dired-log (process-buffer process))
                     (dired-log t)
                     (message "Compress %s %s\nInspect %s buffer" out-file event dired-log-buffer)
                     (kill-buffer (process-buffer process)))))))
          (set-process-sentinel proc sentinel)))))))
#+end_src

**** [[https://github.com/xFA25E/dired-tags][Dired Tags]]
Manage file tags in dired

#+begin_src elisp
(with-eval-after-load 'dired
  (define-key dired-mode-map "\C-c\C-t" 'dired-tags-prefix-map))
#+end_src

*** Disass
#+begin_src elisp
(with-eval-after-load 'disass
  (define-key emacs-lisp-mode-map "\C-c\C-d" 'disassemble)
  (define-key lisp-interaction-mode-map "\C-c\C-d" 'disassemble))
#+end_src

*** [[https://github.com/jacktasia/dumb-jump][Dumb Jump]]
Poor man's goto-definition facility.  It uses regexps and *grep/rg/whatever*.

#+begin_src elisp
(add-hook 'xref-backend-functions 'dumb-jump-xref-activate)
#+end_src

*** [[https://github.com/girzel/ebdb][Ebdb]]
An EIEIO port of BBDB (Big Brother DataBase).  Allows you to save contacts.
Also, integrates with MUAs.

#+begin_src elisp
(define-key mode-specific-map "oe" 'ebdb)

(defvar ebdb-mode-map)
(defvar message-mode-map)

(with-eval-after-load 'ebdb-com
  (define-key ebdb-mode-map "\C-cm" 'ebdb-complete-push-mail-and-quit-window)
  (define-key ebdb-mode-map "\C-cM" 'ebdb-complete-push-mail))

(with-eval-after-load 'message
  (require 'ebdb-message)
  (define-key message-mode-map "\C-ce" 'ebdb-complete))
#+end_src

*** Ediff
#+begin_src elisp
(define-key ediff-command-map "\C-k" 'ediff-backup)
(define-key ediff-command-map "\C-b" 'ediff-buffers)
(define-key ediff-command-map "\C-c" 'ediff-current-file)
(define-key ediff-command-map "\C-d" 'ediff-directories)
(define-key ediff-command-map [?\C-\S-v] 'ediff-directory-revisions)
(define-key ediff-command-map "\C-f" 'ediff-files)
(define-key ediff-command-map "\C-m\C-b" 'ediff-merge-buffers)
(define-key ediff-command-map "\C-m\C-d" 'ediff-merge-directories)
(define-key ediff-command-map [?\C-m ?\C-\S-v] 'ediff-merge-directory-revisions)
(define-key ediff-command-map "\C-m\C-f" 'ediff-merge-files)
(define-key ediff-command-map "\C-m\C-v" 'ediff-merge-revisions)
(define-key ediff-command-map "\C-p\C-b" 'ediff-patch-buffer)
(define-key ediff-command-map "\C-p\C-f" 'ediff-patch-file)
(define-key ediff-command-map "\C-r\C-l" 'ediff-regions-linewise)
(define-key ediff-command-map "\C-r\C-w" 'ediff-regions-wordwise)
(define-key ediff-command-map "\C-v" 'ediff-revision)
(define-key ediff-command-map "\C-w\C-l" 'ediff-windows-linewise)
(define-key ediff-command-map "\C-w\C-w" 'ediff-windows-wordwise)
#+end_src

*** [[https://github.com/Fanael/edit-indirect][Edit Indirect]]
Allows you to edit any region in different /major-mode/.  Very helpful when you
have a file which is a mix of different languages.

#+begin_src elisp
(define-key ctl-x-map "E" 'edit-indirect-region)
#+end_src

*** [[https://github.com/joaotavora/eglot][Eglot]]
#+begin_src elisp
(defvar eglot-mode-map)
(defvar eglot-server-programs)
(with-eval-after-load 'eglot
  (define-key eglot-mode-map "\C-c\C-l" 'eglot-code-actions)
  (setf (alist-get '(js-mode typescript-mode) eglot-server-programs nil nil 'equal)
        '("typescript-language-server" "--tsserver-path" "tsserver" "--stdio"))

  (advice-add 'eglot-xref-backend :override 'xref-eglot+dumb-backend)

  (defun xref-eglot+dumb-backend () 'eglot+dumb)

  (cl-defmethod xref-backend-identifier-at-point ((_backend (eql eglot+dumb)))
    (cons (xref-backend-identifier-at-point 'eglot)
          (xref-backend-identifier-at-point 'dumb-jump)))

  (cl-defmethod xref-backend-identifier-completion-table ((_backend (eql eglot+dumb)))
    (xref-backend-identifier-completion-table 'eglot))

  (cl-defmethod xref-backend-definitions ((_backend (eql eglot+dumb)) identifier)
    (or (xref-backend-definitions 'eglot (car identifier))
        (xref-backend-definitions 'dumb-jump (cdr identifier))))

  (cl-defmethod xref-backend-references ((_backend (eql eglot+dumb)) identifier)
    (or (xref-backend-references 'eglot (car identifier))
        (xref-backend-references 'dumb-jump (cdr identifier))))

  (cl-defmethod xref-backend-apropos ((_backend (eql eglot+dumb)) pattern)
    (xref-backend-apropos 'eglot pattern)))
#+end_src

*** Eldoc
#+begin_src elisp
(add-hook 'nix-mode-hook 'eldoc-mode)
#+end_src

*** Elisp Mode
Some macro-expansion commands.

#+begin_src elisp
(define-key emacs-lisp-mode-map [?\C-c ?\C-\S-m] 'emacs-lisp-macroexpand)
(define-key lisp-interaction-mode-map [?\C-c ?\C-\S-m] 'emacs-lisp-macroexpand)
(with-eval-after-load 'elisp-mode
  (setq elisp-flymake-byte-compile-load-path (cons "./" load-path)))
#+end_src

*** Emacs
Here are some options, that can't be changed through /custom/.  Mostly, because
the developers forgot abouth them.  Shame on developers!

#+begin_src elisp
(setq completion-ignore-case t)
(define-key ctl-x-map "\C-\M-t" 'transpose-regions)
(define-key ctl-x-map "\C-l" 'load-command-map)
#+end_src

*** [[https://github.com/smihica/emmet-mode][Emmet Mode]]
A must-have when you need to write XML by hand.

#+begin_src elisp
(add-hook 'nxml-mode-hook 'emmet-mode)
(add-hook 'mhtml-mode-hook 'emmet-mode)
(add-hook 'web-mode-hook 'emmet-mode)
#+end_src

*** Env
Force programs to disable ansi escape sequences.

#+begin_src elisp
(setenv "PAGER" "cat")
(with-eval-after-load 'env
  (define-key global-map [?\C-\M-$] 'getenv))
#+end_src

*** [[https://github.com/purcell/envrc][Envrc]]
#+begin_src elisp
(with-eval-after-load 'envrc
  (define-key envrc-command-map "R" 'envrc-reload-all)
  (define-key envrc-mode-map "\C-xd" 'envrc-command-map))
#+end_src

*** Files
#+begin_src elisp
(with-eval-after-load 'files
  (define-key ctl-x-map "\C-r" 'region-commands-map)
  (define-key load-command-map "\C-l" 'load-library)
  (define-key load-command-map "\C-f" 'load-file)
  (define-key ctl-x-map "\C-d" 'ediff-command-map))
#+end_src

*** Files X
#+begin_src elisp
(with-eval-after-load 'files-x
  (define-key ctl-x-x-map "ad" 'add-dir-local-variable)
  (define-key ctl-x-x-map "aa" 'add-file-local-variable)
  (define-key ctl-x-x-map "ap" 'add-file-local-variable-prop-line))
#+end_src

*** Find Dired
Another great *GNU/Emacs* feature.  Results of arbitrary *find* commands can be
displayed inside /dired/.

#+begin_src elisp
(define-key search-map "n" 'find-name-dired)
(define-key search-map "N" 'find-dired)

(with-eval-after-load 'find-dired
  (let ((type '(const :tag "Sort file names by video duration" find-dired-sort-by-video-duration))
        (choices (cdr (get 'find-dired-refine-function 'custom-type))))
    (cl-pushnew type choices :test #'equal)
    (put 'find-dired-refine-function 'custom-type (cons 'choice choices)))

  (defun find-dired-sort-by-video-duration ()
    "Sort entries in *Find* buffer by video duration."
    (sort-subr nil 'forward-line 'end-of-line
               (lambda ()
                 (let ((file-name
                        (buffer-substring-no-properties
                         (next-single-property-change
                          (point) 'dired-filename)
                         (line-end-position))))
                   (with-temp-buffer
                     (call-process "video_seconds" nil '(t nil) nil file-name)
                     (string-to-number (buffer-string))))))))
#+end_src

*** Find Func
Usefull commands to jump to /e-lisp/ definitions.

#+begin_src elisp
(define-key ctl-x-map "L" 'find-library)
(define-key ctl-x-map "F" 'find-function)
(define-key ctl-x-map "K" 'find-function-on-key)
(define-key ctl-x-map "V" 'find-variable)
#+end_src

Push xref marker before using some ~find-func~ commands.  By doing this, we can
go back with =M-,=.

#+begin_src elisp
(dolist (fn '(find-library find-function find-function-on-key find-variable))
  (advice-add fn :before 'xref-push-marker-stack-ignore-args))
#+end_src

*** Finder
Show the *Commentary* section of a package.

#+begin_src elisp
(define-key help-map "\M-c" 'finder-commentary)
#+end_src

*** Flymake
On-the-fly linter.

#+begin_src elisp
(add-hook 'nix-mode-hook 'flymake-mode)
(defvar flymake-mode-map)
(with-eval-after-load 'flymake
  (define-key flymake-mode-map "\M-g\M-f" 'flymake-goto-next-error)
  (define-key flymake-mode-map "\M-g\M-b" 'flymake-goto-prev-error))
#+end_src

*** [[https://github.com/orzechowskid/flymake-eslint][Flymake Eslint]]
#+begin_src elisp
(add-hook 'js-mode-hook 'flymake-eslint-enable)
#+end_src

*** [[https://github.com/xFA25E/flymake-statix][Flymake Statix]]
#+begin_src elisp
(add-hook 'nix-mode-hook 'flymake-statix-setup)
(with-eval-after-load 'nix-mode
  (with-eval-after-load 'flymake-statix
    (define-key nix-mode-map "\C-c\C-x" 'flymake-statix-fix)))
#+end_src

*** [[https://github.com/lassik/emacs-format-all-the-code][Format All]]
#+begin_src elisp
(add-hook 'nix-mode-hook 'format-all-mode)
(add-hook 'js-mode-hook 'format-all-mode)
#+end_src

*** Grep
Another great *GNU/Emacs* package.  You can run arbitatry *grep* commands.
*GNU/Emacs* has an unfortunate bug.  It slows down a lot when displaying too
long lines.  To fix this in /grep/, I define this advice that trims the result
to 500 chars.

#+begin_src elisp
(define-key search-map "g" 'rgrep)
(declare-function grep-expand-template@add-cut "grep" (cmd))
(with-eval-after-load 'grep
  (define-advice grep-expand-template (:filter-return (cmd) add-cut)
    (concat cmd " | cut -c-500")))
#+end_src

*** Help
#+begin_src elisp
(define-key ctl-x-map "h" 'help-command)
#+end_src

*** Help Fns
#+begin_src elisp
(with-eval-after-load 'help-fns
  (define-key help-map "\M-f" 'describe-face)
  (define-key help-map "\M-k" 'describe-keymap))
#+end_src

*** Hippie Exp
Handy in-buffer completion.  It can use a lot of sources.  Mostly useful to
complete file-name paths.

#+begin_src elisp
(define-key global-map "\M-\\" 'hippie-expand)
#+end_src

*** Hl Line
Highlight current line in these modes.

#+begin_src elisp
(add-hook 'csv-mode-hook 'hl-line-mode)
(add-hook 'grep-mode-hook 'hl-line-mode)
(add-hook 'tar-mode-hook 'hl-line-mode)
(add-hook 'transmission-files-mode-hook 'hl-line-mode)
(add-hook 'transmission-mode-hook 'hl-line-mode)
(add-hook 'transmission-peers-mode-hook 'hl-line-mode)
(add-hook 'mpc-mode-hook 'hl-line-mode)
#+end_src

*** Ibuffer
#+begin_src elisp
(defvar ibuffer-mode-map)
(with-eval-after-load 'ibuffer (define-key ibuffer-mode-map "\M-o" nil))
#+end_src

*** Ipretty
Pretty-print /e-lisp/ result of last S-EXpression.

#+begin_src elisp
(define-key lisp-interaction-mode-map "\C-j" 'ipretty-last-sexp)
#+end_src

*** Isearch
A great in-buffer search facility.  It is well integrated with ~query-replace~
and ~occur~.

#+begin_src elisp
(define-key isearch-mode-map "\C-h" 'isearch-delete-char)
(define-key isearch-mode-map "\C-?" isearch-help-map)
#+end_src

*** Js
#+begin_src elisp
(defvar js-mode-map)
(with-eval-after-load 'js
  (define-key js-mode-map "\M-." nil))
#+end_src

*** [[https://github.com/ledger/ledger-mode][Ledger Mode]]
Cli, text-based, accounting system.  This particular setting fixes the amount
regex.  By default, it can't recognize amounts with equal sign (~=~) at the
beginning and, as a consequence, can't indent, properly, lines with this kinds
of amounts.

#+begin_src elisp
(defvar ledger-amount-regex)
(defvar ledger-commodity-regexp)
(with-eval-after-load 'ledger-regex
  (setq ledger-amount-regex
        (concat "\\(  \\|\t\\| \t\\)[ \t]*-?"
                "\\(?:" ledger-commodity-regexp " *\\)?"
                "\\([-=]?\\(?:[0-9]+\\|[0-9,.]+?\\)\\)"
                "\\([,.][0-9)]+\\)?"
                "\\(?: *" ledger-commodity-regexp "\\)?"
                "\\([ \t]*[@={]@?[^\n;]+?\\)?"
                "\\([ \t]+;.+?\\|[ \t]*\\)?$")))
#+end_src

*** [[https://github.com/noctuid/link-hint.el][Link Hint]]
Another favorite package of mine.  It lets you do actions to various points of
interest in buffers using Avy.  It can do anything: buttons, links, completion
candidates.  You name it!

#+begin_src elisp
(define-key goto-map "\M-l" 'link-hint-open-link)
(define-key goto-map "\M-L" 'link-hint-copy-link)
(with-eval-after-load 'link-hint
  (cl-pushnew 'rg-mode (get 'link-hint-compilation-link :vars)))
#+end_src

*** Lisp
#+begin_src elisp
(defun change-pair (change-to)
  (interactive "cChange to:")
  (pcase (assq change-to insert-pair-alist)
    ((or `(,open ,close) `(,_ ,open ,close))
     (save-excursion
       (insert-pair 1 open close)
       (delete-pair)))))

(defun slurp-pair ()
  (interactive)
  (save-excursion
    (backward-up-list)
    (save-excursion
      (pcase (assq (char-after) insert-pair-alist)
        ((or `(,open ,close) `(_ ,open ,close))
         (insert-pair 2 open close)
         (delete-pair))))
    (indent-sexp)))

(define-key global-map "\M-]" 'change-pair)
(define-key global-map "\M-[" 'delete-pair)
(define-key global-map [?\C-\)] 'slurp-pair)
#+end_src

*** Loadhist
#+begin_src elisp
(define-key load-command-map "\C-u" 'unload-feature)
#+end_src

*** Locate
Locate integration.  Unfortunately it is using a simplified (and half-assed)
version of /dired/ to display the results.  It bothers me sometimes.

#+begin_src elisp
(define-key search-map "l" 'locate)
#+end_src

*** [[https://github.com/magit/magit][Magit]]
A killer feature.  Best *git* front-end.

#+begin_src elisp
(define-key project-prefix-map "m" 'magit-project-status)
#+end_src

*** Man
Do you like /smoking/ manuals?

#+begin_src elisp
(define-key help-map "\M-m" 'man)
#+end_src

*** Menu Bar
#+begin_src elisp
(with-eval-after-load 'menu-bar
  (define-key ctl-x-map "`" 'toggle-debug-on-error))
#+end_src

*** Minibuffer
Some enhancements for default completion-framework.

#+begin_src elisp
(setq minibuffer-allow-text-properties t)
(define-key completion-in-region-mode-map "\M-v" 'switch-to-completions)
(define-key minibuffer-local-completion-map " " nil)
(define-key minibuffer-local-must-match-map "\C-j" 'minibuffer-force-complete-and-exit)
#+end_src

*** Mpc
Mpc front-end.  It might feel wanky, but that's because it was intended to be
used with ~tool-bar-mode~ enabled.  By giving it some nice keybindings, it
becomes a +butterfly+ nice and usable *mpc* front-end.

#+begin_src elisp
(define-key mode-specific-map "os" 'mpc)
#+end_src

**** Mpc Bindings
Yeah, it does not have default bindings at all!

#+begin_src elisp
(defvar mpc-mode-map)
(defvar mpc-songs-mode-map)
(with-eval-after-load 'mpc
  (define-key mpc-mode-map "p" 'mpc-playlist)
  (define-key mpc-mode-map "u" 'mpc-update)
  (define-key mpc-mode-map "a" 'mpc-playlist-add)
  (define-key mpc-mode-map "c" 'mpc-toggle-consume)
  (define-key mpc-mode-map "r" 'mpc-toggle-repeat)
  (define-key mpc-mode-map "." 'mpc-toggle-single)
  (define-key mpc-mode-map "z" 'mpc-toggle-shuffle)
  (define-key mpc-mode-map "t" 'mpc-toggle-play)
  (define-key mpc-mode-map "s" 'mpc-songs-search)
  (define-key mpc-mode-map "k" 'mpc-songs-kill-search)
  (define-key mpc-mode-map "f" 'mpc-ffwd)
  (define-key mpc-mode-map "b" 'mpc-rewind)
  (define-key mpc-mode-map "D" 'mpc-playlist-delete)
  (define-key mpc-mode-map "m" 'mpc-select-toggle)
  (define-key mpc-mode-map "M" 'mpc-select-extend)
  (define-key mpc-mode-map "\M-m" 'mpc-select)
  (define-key mpc-mode-map "\C-m" 'mpc-songs-jump-to)
  (define-key mpc-songs-mode-map [remap mpc-select] nil)
  (define-key mpc-songs-mode-map "v" 'mpc-move-forward)
  (define-key mpc-songs-mode-map "V" 'mpc-move-backward))
#+end_src

**** Mpc Extensions
Mpc is mouse-oriented by default.  To move songs in a playlist you have to use
drag-n-drop.

#+begin_src elisp
(declare-function mpc-move-forward "mpc")
(declare-function mpc-songs-refresh "mpc")
(declare-function mpc-cmd-move "mpc")
(with-eval-after-load 'mpc
  (defun mpc-move-forward (n)
    (interactive "p")
    (let ((point-max (point-max)))
      (unless (= 1 point-max)
        (when-let ((last-pos (get-text-property (1- point-max) 'mpc-file-pos))
                   (cur-pos (get-text-property (point) 'mpc-file-pos)))
          (let ((new-pos (+ cur-pos n)))
            (when (<= 0 new-pos last-pos)
              (mpc-cmd-move (list cur-pos) new-pos)
              (mpc-songs-refresh)))))))

  (defun mpc-move-backward (n)
    (interactive "p")
    (mpc-move-forward (- n))))
#+end_src

*** Net Utils
Some good net utils, when you need to find out why your pages won't load in your
default web-browser.

#+begin_src elisp
(define-key mode-specific-map "nh" 'nslookup-host)
(define-key mode-specific-map "ni" 'ifconfig)
(define-key mode-specific-map "nn" 'netstat)
(define-key mode-specific-map "np" 'ping)
(define-key mode-specific-map "nw" 'iwconfig)
#+end_src

*** Newcomment
#+begin_src elisp
(with-eval-after-load 'newcomment
  (define-key global-map [?\C-\;] 'comment-line))
#+end_src

*** Newsticker
An out-of-the-box rss/atom reader.  It has some bizarre defaults, but it is very
usable.

#+begin_src elisp
(define-key mode-specific-map "on" 'newsticker-show-news)
#+end_src

*** [[https://github.com/NixOS/nix-mode][Nix Mode]]
#+begin_src elisp
(add-hook 'proced-mode-hook 'nix-prettify-mode)

(with-eval-after-load 'nix-mode
  (define-key nix-mode-map "\C-c\C-e" 'nix-edit)
  (define-key nix-mode-map "\C-c\C-f" 'nix-flake)
  (define-key nix-mode-map "\C-c\C-r" 'nix-repl)
  (define-key nix-mode-map "\C-c\C-s" 'nix-search)
  (define-key nix-mode-map "\C-c\C-p" 'nix-store-show-path))

(declare-function nix-edit@flake "nix-edit")
(with-eval-after-load 'nix-edit
  (define-advice nix-edit (:override () flake)
    (interactive)
    (let ((cmd (read-shell-command "Nix edit command: " "nix edit "))
          (process-environment (cons "EDITOR=echo" process-environment)))
      (find-file
       (with-temp-buffer
         (call-process-shell-command cmd nil (list (current-buffer) nil) nil)
         (buffer-substring-no-properties (point-min) (1- (point-max))))))))

(defvar nix-flake-ref)
(declare-function nix-flake--installable-command "nix-flake")
(declare-function nix-flake--build-attribute-names "nix-flake")
(declare-function nix-flake--options "nix-flake")
(declare-function nix-flake--registry-refs@all "nix-flake")
(declare-function nix-flake--registry-list "nix-flake")
(declare-function nix-flake-run-attribute@shell "nix-flake")
(declare-function nix-flake--run-attribute-names "nix-flake")
(with-eval-after-load 'nix-flake
  (define-advice nix-flake--registry-refs (:override () all)
    (cl-delete-duplicates
     (cl-remove
      "path:"
      (flatten-list (mapcar #'cdr (nix-flake--registry-list)))
      :test #'string-prefix-p)
     :test #'string=))

  (define-advice nix-flake-run-attribute
      (:override (options flake-ref attribute command-args &optional comint)
                 shell)
    (interactive (list (nix-flake--options)
                       nix-flake-ref
                       (completing-read "Nix app/package: "
                                        (nix-flake--run-attribute-names))
                       nil
                       (consp current-prefix-arg)))
    (let ((default-directory (project-root (project-current t)))
          (compilation-buffer-name-function
           (or project-compilation-buffer-name-function
               compilation-buffer-name-function)))
      (compile (nix-flake--installable-command "run" options flake-ref attribute
                                               command-args)
               comint)))

  (defun nix-flake-log-attribute (options flake-ref attribute)
    "Log a derivation in the current flake.

For OPTIONS, FLAKE-REF, and ATTRIBUTE, see the documentation of
`nix-flake-run-attribute'."
    (interactive (list (nix-flake--options)
                       nix-flake-ref
                       (completing-read "Nix package: "
                                        (nix-flake--build-attribute-names))))
    (compile (nix-flake--installable-command "log" options flake-ref attribute)))

  (transient-append-suffix 'nix-flake-dispatch '(2 -1)
    '("l" "Log attribute" nix-flake-log-attribute)))

(declare-function nix-search--display@display-buffer "nix-search")
(with-eval-after-load 'nix-search
  (define-advice nix-search--display (:filter-args (args) display-buffer)
    (list (car args) (get-buffer-create "*Nix-Search*") (cddr args))))

(with-eval-after-load 'nix-shell
  (define-advice nix-read-flake (:override () always-prompt)
    (let ((default "nixpkgs"))
      (read-string (format-prompt "Nix flake" default) nil nil default))))

(defun nix-compile-in-project-advice (fn &rest args)
  (let ((default-directory (project-root (project-current t)))
        (compilation-buffer-name-function
         (or project-compilation-buffer-name-function
             compilation-buffer-name-function)))
    (apply fn args)))

(dolist (fn '(nix-flake-log-attribute
              nix-flake-run-default
              nix-flake-build-attribute
              nix-flake-build-default
              nix-flake-check
              nix-flake-lock
              nix-flake-update))
  (advice-add fn :around 'nix-compile-in-project-advice))
#+end_src

*** [[https://github.com/xFA25E/nixos-options][Nixos Options]]
#+begin_src elisp
(add-hook 'nixos-options-mode-hook 'nix-prettify-mode)
(with-eval-after-load 'nix-mode
  (define-key nix-mode-map "\C-c\C-o" 'nixos-options))
#+end_src

*** [[https://notmuchmail.org/notmuch-emacs/][Notmuch]]
My main MUA.  The tag system is fantastic.  Switched to it after using /mu4e/
for some years. [[https://www.youtube.com/watch?v=3xWEnAVl1Tw][Thanks!]]

#+begin_src elisp
(define-key mode-specific-map "om" 'notmuch)
(autoload 'notmuch-mua-mail "notmuch-mua")
(define-mail-user-agent 'notmuch-user-agent 'notmuch-mua-mail 'notmuch-mua-send-and-exit 'notmuch-mua-kill-buffer 'notmuch-mua-send-hook)
#+end_src

*** [[https://depp.brause.cc/nov.el/][Nov]]
You can read EPUB in *GNU/Emacs*.

#+begin_src elisp
(add-to-list 'auto-mode-alist (cons (rx ".epub" eos) 'nov-mode))
#+end_src

*** Novice
Some commands in *GNU/Emacs* are disabled by default, because they are thought
to be confusing for novices.  [[https://github.com/xFA25E/images/raw/main/do-nice-things-to-normies.mp4][As one famous philosopher said]].

#+begin_src elisp
(setq disabled-command-function nil)
#+end_src

*** [[https://github.com/zweifisch/ob-http][Ob Http]]
A great http client that uses /Org Mode/.  It does not add itself to
~org-babel-load-languges~ /custom/ type.  Let's help it to be even greater.

#+begin_src elisp
(with-eval-after-load 'org
  (cl-pushnew
   '(const :tag "Http" http)
   (cdadr (memq :key-type (get 'org-babel-load-languages 'custom-type)))
   :test 'equal))
#+end_src

*** Org
Who doesn't know /org-mode/?  This is another killer feature of *GNU/Emacs*.

#+begin_src elisp
(defvar org-mode-map)
(with-eval-after-load 'org
  (define-key org-mode-map [?\C-c?\C-\S-t] 'org-todo-yesterday))
#+end_src

Play a sound after org notification.  I know that one could use
~org-show-notification-handler~, but I'm lazy!

#+begin_src elisp
(define-advice org-show-notification (:after (&rest _) sound)
  (call-process "notify_bruh" nil 0 nil))
#+end_src

**** Org Agenda
My tasks, habits etc.

#+begin_src elisp
(define-key mode-specific-map "Ga" 'org-agenda)
(defvar org-agenda-mode-map)
(with-eval-after-load 'org-agenda
  (define-key org-agenda-mode-map "T" 'org-agenda-todo-yesterday))
#+end_src

**** Org Capture
This is like enhanced /remember-mode/.

#+begin_src elisp
(define-key mode-specific-map "Gc" 'org-capture)
#+end_src

**** [[https://github.com/org-mime/org-mime][Org Mime]]
Write your e-mail in /org-mode/.

#+begin_src elisp
(autoload 'org-mime-edit-mail-in-org-mode "org-mime" nil t)
(autoload 'org-mime-revert-to-plain-text-mail "org-mime" nil t)
(with-eval-after-load 'message
  (define-key message-mode-map "\C-c\M-o" 'org-mime-htmlize)
  (define-key message-mode-map "\C-c\M-e" 'org-mime-edit-mail-in-org-mode)
  (define-key message-mode-map "\C-c\M-t" 'org-mime-revert-to-plain-text-mail))
#+end_src

**** [[https://github.com/org-roam/org-roam][Org Roam]]
Personal wiki - knowledge database.

#+begin_src elisp
(define-key mode-specific-map "Gf" 'org-roam-node-find)
(define-key mode-specific-map "Gi" 'org-roam-node-insert)
(define-key mode-specific-map "Gl" 'org-roam-buffer-toggle)
(define-key mode-specific-map "Gs" 'org-roam-db-sync)
(declare-function org-roam-db-autosync-mode "org-roam-db" (&optional arg))
(with-eval-after-load 'org-roam (org-roam-db-autosync-mode))
#+end_src

*** Paragraphs
Sometimes I need to transpose paragraphs.

#+begin_src elisp
(define-key global-map [?\C-\M-\S-t] 'transpose-paragraphs)
#+end_src

*** [[https://github.com/politza/pdf-tools][Pdf Tools]]
Do you like viewing PDFs?

#+begin_src elisp
(declare-function pdf-loader-install "pdf-loader" (&optional no-query-p skip-dependencies-p no-error-p force-dependencies-p))
(pdf-loader-install t t)
#+end_src

*** Pp
Small PP!  Another pretty-printer for /e-lisp/ S-EXpressions.

#+begin_src elisp
(define-key emacs-lisp-mode-map "\C-c\C-m" 'pp-macroexpand-last-sexp)
(define-key lisp-interaction-mode-map "\C-c\C-m" 'pp-macroexpand-last-sexp)
#+end_src

*** Proced
Poor man's *htop*.

#+begin_src elisp
(define-key mode-specific-map "op" 'proced)
#+end_src

*** [[https://github.com/xFA25E/pueue][Pueue]]
A queue of tasks.  Used mostly for downloading youtube videos through
*youtube-dl*.

#+begin_src elisp
(define-key mode-specific-map "ou" 'pueue)
(add-hook 'pueue-mode-hook 'hl-line-mode)
#+end_src

*** Register
Are you familiar with registers?  You can store things!

#+begin_src elisp
(define-key ctl-x-r-map "v" 'view-register)
(define-key ctl-x-r-map "L" 'list-registers)
(define-key ctl-x-r-map "p" 'prepend-to-register)
(define-key ctl-x-r-map "a" 'append-to-register)
#+end_src

*** Re Builder
#+begin_src elisp
(define-key emacs-lisp-mode-map "\C-c\C-r" 're-builder)
(define-key lisp-interaction-mode-map "\C-c\C-r" 're-builder)
#+end_src

*** Replace
#+begin_src elisp
(define-key region-commands-map "\C-k" 'keep-lines)
(define-key region-commands-map "\C-f" 'flush-lines)
#+end_src

*** [[https://github.com/a13/reverse-im.el][Reverse Im]]
It is very difficult to explain what this package does.  Imagine yourself being
a speaker of a language with a cyrillic alphabet.  You would like to write
something in this, bizarre, language and use *GNU/Emacs* bindings at the same
time.  That's what this package does.

#+begin_src elisp
(require 'reverse-im)
(reverse-im-activate "cyrillic-dvorak")
#+end_src

*** [[https://github.com/dajva/rg.el][Rg]]
Super fast *grep*-killer.  In *Rust* we trust.

#+begin_src elisp
(define-key search-map "r" 'rg-menu)
#+end_src

*** [[https://github.com/xFA25E/rx-widget][Rx Widget]]
#+begin_src elisp
(with-eval-after-load 'wid-edit
  (require 'rx-widget)
  (define-widget 'regexp 'rx-widget "A regular expression in rx form."))
#+end_src

*** Savehist
Persistent history in the minibuffer.  This particular setting is used to filter
out: remote files, http links or non-existent files.

#+begin_src elisp
(with-eval-after-load 'savehist
  (defun savehist-filter-file-name-history ()
    (let (result)
      (dolist (file-name file-name-history)
        (let ((f (string-trim-right (expand-file-name file-name) "/+")))
          (unless (string-empty-p f)
            (when (or (file-remote-p f)
                      (string-match-p "\\`http" f)
                      (file-exists-p f))
              (cl-pushnew f result :test #'string-equal)))))
      (setq file-name-history result))))
#+end_src

*** [[https://github.com/xFA25E/sdcwoc][SDCWOC]]
Do you like browsing dictionaries offline inside *GNU/Emacs*?

#+begin_src elisp
(define-key mode-specific-map "ot" 'sdcwoc)
#+end_src

*** Sgml Mode
Mode for editing all XML-like languages.

#+begin_src elisp
(defvar html-mode-map)
(defvar sgml-mode-map)
(with-eval-after-load 'sgml-mode
  (define-key sgml-mode-map "\C-\M-n" 'sgml-skip-tag-forward)
  (define-key sgml-mode-map "\C-\M-p" 'sgml-skip-tag-backward)
  (define-key sgml-mode-map "\C-c\C-r" 'sgml-namify-char)
  (define-key html-mode-map "\M-o" nil))
#+end_src

*** Shell
Plain old shell.  I prefer it to /eshell/ because it uses proper pipes.

#+begin_src elisp
(define-key mode-specific-map "s" 'shell)
(define-key mode-specific-map "l" 'shell-list)

(defun shell-list (&optional other-window-p)
  "Open shell buffers in ibuffer.
`OTHER-WINDOW-P' is like in `ibuffer'."
  (interactive "P")
  (let ((buffer-name "*Shells-List*"))
    (ibuffer other-window-p buffer-name `((mode . shell-mode)) nil nil
             '(("Project shells" (name . "-shell\\*\\'"))
               ("Shells" (name . "\\`\\*shell\\*"))
               ("Async shell commands" (name . "\\`\\*Async Shell Command\\*")))
             '((mark " " (name 40 50 :left :elide) " " filename-and-process)))
    (with-current-buffer buffer-name
      (setq-local ibuffer-use-header-line nil)
      (hl-line-mode t))))
#+end_src

*** Simple
Some useful *GNU/Emacs* commands not bound by default (for some unknown reason).

#+begin_src elisp
(defun cycle-spacing-fast (&optional n)
  (interactive "*p")
  (cycle-spacing n nil 'fast))

(defun kill-region-dwim (&optional count)
  (interactive "p")
  (if (use-region-p)
      (kill-region (region-beginning) (region-end))
    (backward-kill-word count)))

(define-key global-map "\C-h" 'backward-delete-char-untabify)
(define-key global-map "\M-K" 'kill-whole-line)
(define-key global-map "\M-c" 'capitalize-dwim)
(define-key global-map "\M-l" 'downcase-dwim)
(define-key global-map "\M-u" 'upcase-dwim)
(define-key global-map "\C-w" 'kill-region-dwim)
(define-key global-map "\M- " 'cycle-spacing-fast)
(define-key global-map "\M-\\" 'delete-indentation)
(define-key ctl-x-map "w" 'mark-whole-buffer)
(define-key ctl-x-x-map "f" 'auto-fill-mode)
(define-key ctl-x-x-map "v" 'visual-line-mode)
(define-key ctl-x-x-map "w" 'whitespace-mode)
(define-key mode-specific-map "oP" 'list-processes)
#+end_src

*** [[https://github.com/xFA25E/skempo][Skempo]]
Enhance default *GNU/Emacs* templates.  I don't like Yasnippet, so I wrote a
package that fixes problems of /tempo/ and /skeleton/.

#+begin_src elisp
(add-hook 'nix-mode-hook 'skempo-mode)
(add-hook 'js-mode-hook 'skempo-mode)

(defvar skempo-mode-map)
(with-eval-after-load 'skempo
  (define-key skempo-mode-map "\C-z" 'skempo-complete-tag-or-call-on-region)
  (define-key skempo-mode-map "\M-g\M-e" 'skempo-forward-mark)
  (define-key skempo-mode-map "\M-g\M-a" 'skempo-backward-mark)
  (load (expand-file-name "emacs/skempo-templates.el" (xdg-config-home))))
#+end_src

**** Templates
:properties:
:header-args:elisp: :tangle skempo-templates.el
:end:

/Tempo/ is very extensible.  Here, I define a function that processes unknown
elements to /tempo/ and returns other /tempo/ elements.  Very easy.

#+begin_src elisp
;; -*- lexical-binding: t; -*-

(eval-when-compile (require 'skempo))

(defun tempo-custom-user-elements (arg)
  (pcase arg
    (:nix-hash (make-string 52 ?1))
    (:elisp-namespace
     (string-trim
      (replace-regexp-in-string
       (rx (+ (not (any "a-z")))) "-"
       (string-trim-right (downcase (buffer-name)) (rx ".el" eos)))
      "-" "-"))
    (:elisp-group (string-trim-right (buffer-name) (rx (? "-mode") ".el" eos)))
    (`(:lisp-with-parens . ,body)
     (if (or (not (eql (char-before) ?\()) (use-region-p))
         `(l "(" ,@body ")")
       `(l ,@body)))))

(add-to-list 'tempo-user-elements 'tempo-custom-user-elements)
#+end_src

***** Lisp
I don't want to trigger automatic expansion on any non-word character in lisp
tempaletes.  I want them to be triggered on space or on ~expand-abbrev~.

#+begin_src elisp
(let ((enable-fn (lambda () (or (eq this-command 'expand-abbrev)
                                (eql ?\s last-command-event)))))
  (dolist (mode '(lisp-mode emacs-lisp-mode))
    (let ((table (skempo--abbrev-table mode)))
      (define-abbrev-table table nil :enable-function enable-fn))))

(skempo-define-tempo lambda (:mode (emacs-lisp-mode lisp-mode) :tag t :abbrev t)
  (:lisp-with-parens
   "lambda (" p ") " r>))

(skempo-define-tempo let (:mode (emacs-lisp-mode lisp-mode) :tag t :abbrev t)
  (:lisp-with-parens
   "let ((" p "))" n>
   r>))

(skempo-define-tempo let* (:mode (emacs-lisp-mode lisp-mode) :tag t :abbrev t)
  (:lisp-with-parens
   "let* ((" p "))" n>
   r>))
#+end_src

****** Common Lisp
#+begin_src elisp
(skempo-define-tempo defvar (:mode lisp-mode :tag t :abbrev t)
  (:lisp-with-parens
   "defvar " p n>
   r> n>
   "\"" p "\""))

(skempo-define-tempo defun (:mode lisp-mode :tag t :abbrev t)
  (:lisp-with-parens
   "defun " p " (" p ")" n>
   "\"" p "\"" n>
   r>))

(skempo-define-tempo defpackage (:mode lisp-mode :tag t :abbrev t)
  (:lisp-with-parens
   "defpackage #:" (P "Package name: " package) n>
   "(:use #:cl)" n>
   (:when ("Nickname: " nickname)
          "(:nicknames #:" (s nickname)
          (:while ("Nickname: " nickname) " #:" (s nickname))
          ")" n>)
   (:when ("Local nickname: " local-nickname)
          (:when ("For package: " local-package)
                 "(:local-nicknames (#:" (s local-nickname) " #:" (s local-package) ")"
                 (:while ("Local nickname: " local-nickname)
                         (:when ("For package: " local-package)
                                " (#:" (s local-nickname) " #:" (s local-package) ")"))
                 ")" n>))
   (:while ("Import from: " import-package)
           (:when ("Import symbol: " import-symbol)
                  "(:import-from #:" (s import-package) " #:" (s import-symbol)
                  (:while ("Import symbol: " import-symbol) " #:" (s import-symbol))
                  ")" n>))
   (:when ("Export: " export)
          "(:export #:" (s export)
          (:while ("Export: " export) " #:" (s export))
          ")" n>)
   "(:documentation \"" (P "Documentation: ") "\"))" n>
   "(in-package #:" (s package) ")" n>))

(skempo-define-tempo defsystem (:mode lisp-mode :tag t :abbrev t)
  (:lisp-with-parens
   "defsystem \"" (P "System: " system) "\"" n>
   (:when ("Long name: " long-name) ":long-name \"" (s long-name) "\"" n>)
   (:when ("Version: " version) ":version \""  (s version) "\"" n>)
   (:when ("Author: " author) ":author \"" (s author) "\"" n>)
   (:when ("Maintainer: " maintainer) ":maintainer \"" (s maintainer) "\"" n>)
   (:when ("Mailto: " mailto) ":mailto \"" (s mailto) "\"" n>)
   (:when ("License (ex: GPL3): " license) ":license \"" (s license) "\"" n>)
   (:when ("Homepage: " homepage) ":homepage \"" (s homepage) "\"" n>)
   (:when ("Bug tracker: " bug-tracker) ":bug-tracker \"" (s bug-tracker) "\"" n>)
   (:when ("Source control (ex: git): " source-control)
          (:when ("Link: " link) ":source-control (:" (s source-control) " \"" (s link) "\")" n>))
   (:when ("Description: " description) ":description \"" (s description) "\"" n>)
   ":long-description #.(let ((file (probe-file* (subpathname *load-pathname* \"README.md\")))) (when file (read-file-string file)))" n>
   (:when ("Dependency: " dependency)
          ":depends-on (" "\"" (s dependency) "\""
          (:while ("Dependency: " dependency) " \"" (s dependency) "\"")
          ")" n>)
   ":components ((:module \"src\" :components ((:file \"" (s system) "\"))))" n>
   ":in-order-to ((test-op (test-op \"" (s system) "/tests\"))))" n>
   n>
   "(defsystem \"" (s system) "/tests\"" n>
   ":depends-on (\"" (s system) "\" \"fiveam\")" n>
   ":components ((:module \"tests\" :components ((:file \"" (s system) "\"))))" n>
   ":perform (test-op (op c) (symbol-call '#:fiveam '#:run! (find-symbol* '#:" (s system) " '#:" (s system) ".tests)))"))
#+end_src

****** Emacs Lisp
They are different from Common Lisp, because I want every e-lisp symbol to be
prefixed with buffer name.

#+begin_src elisp
(skempo-define-tempo defvar (:mode emacs-lisp-mode :tag t :abbrev t)
  (:lisp-with-parens
   "defvar " :elisp-namespace "-" p n>
   r> n>
   "\"" p "\""))

(skempo-define-tempo defun (:mode emacs-lisp-mode :tag t :abbrev t)
  (:lisp-with-parens
   "defun " :elisp-namespace "-" p " (" p ")" n>
   "\"" p "\"" n>
   r>))

(skempo-define-tempo defgroup (:mode emacs-lisp-mode :tag t :abbrev t)
  (:lisp-with-parens
   "defgroup " :elisp-group " nil" n>
   "\"" p "\"" n>
   ":group " p "nil"))

(skempo-define-tempo defcustom (:mode emacs-lisp-mode :tag t :abbrev t)
  (:lisp-with-parens
   "defcustom " :elisp-namespace "-" p n>
   r> n>
   "\"" p "\"" n>
   ":type " p "nil" n>
   ":group '" :elisp-group))

(skempo-define-tempo defface (:mode emacs-lisp-mode :tag t :abbrev t)
  (:lisp-with-parens
   "defface " :elisp-namespace "-" p n>
   "'((t :inherit " p "nil))" n>
   "\"" p "\"" n>
   ":group '" :elisp-group))
#+end_src

***** Js
#+begin_src elisp
(skempo-define-tempo switch (:mode js-mode :tag t :abbrev t)
  "switch (" p ") {" n>
  (:while ("Pattern: " pat)
          "case " (s pat) ":" > n>
          p n>
          "break;" n>)
  "default:" > n>
  p n>
  "break;" n>
  "}" >)

(skempo-define-tempo function (:mode js-mode :tag t :abbrev t)
  "function " p "(" p ") {" n>
  r> n>
  "}" >)

(skempo-define-tempo if (:mode js-mode :tag t :abbrev t)
  "if (" p ") {" n>
  r> n>
  "}" >)

(skempo-define-tempo for (:mode js-mode :tag t :abbrev t)
  "for (" p ") {" n>
  r> n>
  "}" >)

(skempo-define-tempo try (:mode js-mode :tag t :abbrev t)
  "try {" n>
  r> n>
  "} catch (" p "error) {" > n>
  p n>
  "}" >)

(skempo-define-tempo clog (:mode js-mode :tag t :abbrev t)
  "console.log(" r ")")

(skempo-define-tempo ctime (:mode js-mode :tag t :abbrev t)
  "console.time(\"" (P "Time name: " time) "\");" > n>
  r> n>
  "console.timeEnd(\"" (s time) "\");" >)
#+end_src

***** Nix
Very useful nix templates.

#+begin_src elisp
(skempo-define-tempo github (:mode nix-mode :tag t :abbrev t)
  "fetchFromGitHub {" n>
  "owner = \"" p "\";" n>
  "repo = \"" p "\";" n>
  "rev = \"" p "\";" n>
  "sha256 = \"" p :nix-hash "\";" n>
  "}" p >)

(skempo-define-tempo url (:mode nix-mode :tag t :abbrev t)
  "fetchurl {" n>
  "url = \"" p "\";" n>
  "sha256 = \"" p :nix-hash "\";" n>
  "}" p >)

(skempo-define-tempo zip (:mode nix-mode :tag t :abbrev t)
  "fetchzip {" n>
  "url = \"" p "\";" n>
  "sha256 = \"" p :nix-hash "\";" n>
  "}" p >)

(skempo-define-tempo git (:mode nix-mode :tag t :abbrev t)
  "fetchgit {" n>
  "url = \"" p "\";" n>
  "rev = \"" p "\";" n>
  "sha256 = \"" p :nix-hash "\";" n>
  "}" p >)
#+end_src

***** Php
#+begin_src elisp
(skempo-define-tempo vd (:mode php-mode :tag t :abbrev t)
  "echo '<pre>'; var_dump(" r "); echo '</pre>';")
#+end_src

***** Org
#+begin_src elisp
(skempo-define-tempo readmeorg (:mode org-mode :tag t :abbrev t)
  "#+TITLE: " (P "Project title: ") n
  (P "A short, one-line description of the project: ") n
  n
  "* Overview" n
  p "# A longer description of the project" n
  n
  "** Features" n
  "** History" n
  "** Motivation" n
  "* Usage" n
  p "# Examples of usage" n
  n
  "* Documentation" n
  "* License" n
  "Copyright (c) " (format-time-string "%Y") " " (P "Authors: ") n
  "Licensed under the " p "GPL3 License." n
  n
  "* COMMENT Local Variables" n
  "# Local "
  "Variables:" n
  "# eval: (add-hook 'after-save-hook #'org-md-export-to-markdown nil t)" p n
  "# End:")
#+end_src

*** Sort
#+begin_src elisp
(define-key region-commands-map "\C-d" 'delete-duplicate-lines)
(define-key region-commands-map "\C-l" 'sort-fields)
(define-key region-commands-map "\C-m" 'sort-columns)
(define-key region-commands-map "\C-n" 'sort-numeric-fields)
(define-key region-commands-map "\C-r" 'reverse-region)
(define-key region-commands-map "\C-s" 'sort-lines)
(define-key region-commands-map "\C-x" 'sort-regexp-fields)
#+end_src

*** Subword
Consider ~SubWord~ as two separate words.  Useful for camel-case languages.

#+begin_src elisp
(add-hook 'rust-mode-hook 'subword-mode)
(add-hook 'nix-mode-hook 'subword-mode)
(add-hook 'js-mode-hook 'subword-mode)
#+end_src

*** Tex Mode
Small settings for /tex-mode/ and /ispell/.  Never used it :/

#+begin_src elisp
(defvar ispell-parser)
(add-hook 'tex-mode-hook (lambda nil (setq-local ispell-parser 'tex)))
#+end_src

*** Text Mode
#+begin_src elisp
(autoload 'center-region "text-mode")
(define-key region-commands-map "\C-c" 'center-region)
#+end_src

*** Term
#+begin_src elisp
(define-key mode-specific-map "t" 'term)
#+end_src

*** Tramp Cmds
#+begin_src elisp
(define-key ctl-x-x-map "T" 'tramp-cleanup-all-buffers)
#+end_src

*** [[https://github.com/holomorph/transmission][Transmission]]
Do you like downloading torrents?

#+begin_src elisp
(define-key mode-specific-map "or" 'transmission)
(defvar transmission-mode-map)
(declare-function transmission-request "transmission" (method &optional arguments tag))
(declare-function transmission-torrents "transmission" (response))
(declare-function transmission-draw-info@comment "transmission" (id))
(with-eval-after-load 'transmission
  (define-key transmission-mode-map "M" 'transmission-move)
  (define-advice transmission-draw-info (:after (id) comment)
    (let* ((arguments `(:ids ,id :fields ["comment"]))
           (response (transmission-request "torrent-get" arguments))
           (torrent (aref (transmission-torrents response) 0)))
      (insert "\nComment: " (or (cdr (assq 'comment torrent)) "")))))
#+end_src

*** [[https://github.com/emacs-tree-sitter/elisp-tree-sitter][Tree Sitter]]
#+begin_src elisp
(add-hook 'css-mode-hook 'tree-sitter-mode)
(add-hook 'js-mode-hook 'tree-sitter-mode)
(add-hook 'mhtml-mode-hook 'tree-sitter-mode)
(add-hook 'nix-mode-hook 'tree-sitter-mode)
(add-hook 'python-mode-hook 'tree-sitter-mode)
(add-hook 'rust-mode-hook 'tree-sitter-mode)
#+end_src

*** Url Parse
This is a *GREAT POSOS* (from rus: posos -> sosat -> сосать -> to suck), as I
like to call it.  Because /url-parse/ doesn't protect ~match-data~, it fucks up
~url-handler-mode~ and, as a result, fucks up /org-mime/ too.

#+begin_src elisp
(declare-function url-generic-parse-url@save-match-data "url-parse" (fn &rest args))
(with-eval-after-load 'url-parse
  (define-advice url-generic-parse-url (:around (fn &rest args) save-match-data)
    (save-match-data (apply fn args))))
#+end_src

*** [[https://github.com/fxbois/web-mode][Web Mode]]
You can edit files with a lot of different web languages in it.

#+begin_src elisp
(add-to-list 'auto-mode-alist (cons (rx ".twig" eos) 'web-mode))
#+end_src

*** Widget
#+begin_src elisp
(defvar widget-field-keymap)
(defvar widget-text-keymap)
(with-eval-after-load 'wid-edit
  (define-key widget-field-keymap "\C-xnf" 'widget-narrow-to-field)
  (define-key widget-text-keymap "\C-xnf" 'widget-narrow-to-field))
#+end_src

*** Window
Do you like windows?  Me neither.

#+begin_src elisp
(define-key global-map "\M-V" 'scroll-down-line)
(define-key global-map [?\C-\S-v] 'scroll-up-line)
(define-key global-map [?\C-\M-\S-b] 'previous-buffer)
(define-key global-map [?\C-\M-\S-f] 'next-buffer)
(define-key global-map "\M-Q" 'quit-window)
(define-key global-map "\M-o" 'other-window)
#+end_src

*** [[https://github.com/magit/with-editor][With Editor]]
#+begin_src elisp
(define-key global-map [?\C-\M-&] 'with-editor-async-shell-command)
#+end_src

*** Xref
Built-in general facility for finding and referencing definitions.  Here, a
function is defined that saves current place to xref stack, but it ignores it's
arguments.  It is used mostly in advices and hooks.

#+begin_src elisp
(autoload 'xref-push-marker-stack "xref")
(defun xref-push-marker-stack-ignore-args (&rest _)
  (xref-push-marker-stack))
#+end_src

** Load Custom
Finally, I load [[custom.el]] settings.

#+begin_src elisp
(declare-function xdg-config-home "xdg" ())
(load (expand-file-name "emacs/custom.el" (xdg-config-home)) nil nil t)
#+end_src

* COMMENT Local Variables
# Local Variables:
# eval: (add-hook 'after-save-hook (lambda nil (org-babel-tangle) (byte-recompile-directory (expand-file-name "./"))) nil t)
# End:
