#+title: Average GNU/Emacs Enjoyer's config

#+options: toc:nil
#+property: header-args:elisp :results silent

For a long time, I refused to write a literate emacs config.  The main reason
was that, I thought that it was needed only for novices, who do not know any
/e-lisp/.  An /e-lisp/ expert does not need any code explanations and I don't
really care about *GNU/Emacs* novices.

Why I changed my mind?  Because, /org-mode/, besides code comments, provides a
good *structure* for your config.  Structure is important.  I could have it by
splitting the file into multiple ones, but I like the idea of having everything
in one place for *GNU/Emacs* config.  In fact, previously, I was using
~outline-minor-mode~.  Also, I wanted to write something.

So, here we go, my *GNU/Emacs* config.

- [[#init][Init]]
- [[#skempo-templates][Skempo Templates]]

* Early Init
:properties:
:header-args:elisp: :tangle early-init.el
:end:

First thing first.  *GNU/Emacs* now has an /early-init.el/ file.  It is a
special file that is loaded before the package system and GUI is initialized.
It is a good place to fine-tune the startup performance.

#+begin_src elisp
;; -*- lexical-binding: t; -*-
#+end_src

** Garbage Collector
The big idea here is to make the garbage collector threshold high as possible
during the loading of /init.el/ and restore it after.  By doing this,
*GNU/Emacs* would have minimal number of garbage collections and, as a result,
startup will be faster.  I'm not claiming to be a low-level *GNU/Emacs* expert,
feel free to correct me.

#+begin_src elisp
(let ((old-threshold gc-cons-threshold))
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold old-threshold)))
  (setq gc-cons-threshold most-positive-fixnum))
#+end_src

** Startup time
This is a nice little snippet of code, that helps you stay in a good shape.  If
your startup time is bigger than the usual, you fucked something up.  Also, it
enhances your ability to *FLEX* on /e-lisp/ peasants.

#+begin_src elisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "Emacs ready in %s with %d garbage collections." (emacs-init-time) gcs-done)))
#+end_src

** Rest
An import of /xdg/ library.  If you are still not using [[https://wiki.archlinux.org/title/XDG_Base_Directory][XDG]], you might consider
+killing yourself+ start using it.  It provides a good *STRUCTURE™* to your
hamster (from rus: hamster -> хомяк -> homyak -> home).

#+begin_src elisp
(require 'xdg)
#+end_src

* Init
:properties:
:header-args:elisp: :tangle init.el
:end:

Here is the juicy part of my *GNU/Emacs* config.  We start by writing a header.

#+begin_src elisp
;; -*- lexical-binding: t; -*-
#+end_src

** Packages
/Based on a true story/

"Bruh, what is this, you are not using /use-package/, it's 2k20, bruh" some
*GNU/Emacs* peasant said.

"Bruh, you are using /custom/, it is a tool from the 90s" ejaculated another
one.

They hated Jesus, because he told them the truth.

--

For real, though.  I've used four different ways of organizing packages in my
config.  First, it was plain /e-lisp/ code, without much *STRUCTURE™*.  I loved
the freedom aspect of it.

Then, came the /use-package/ era.  It provided a lot of *STRUCTURE™*, at the
cost of freedom.  Also, it hided away many things and provided a lot of
questionable features by defaults.  For example: it removed ~-hook~ from hooks
or autoloaded everything.  Autoloading is a good thing, but, you, almost, never
have to do it manually.  Most packages have good autoload cookies by default.
The only situation in which you might need autoloads, is when you write your own
files in *GNU/Emacs* config directory (which are not processed by /package.el/).
Even there you can generate autoload cookies.  Also, /use-package/ has an
enormous and complicated code base.

So, I switched to /leaf/.  It fixed many problems that I had with /use-package/.
Smaller code base, better defaults etc.  But, I still felt that something was
wrong with this approach.  At the time, I also started using [[../overlays/emacs.nix][Nix]] to manage my
*GNU/Emacs* packages, so the feeling of /use-package/ (or /leaf/) being
redundant grew even bigger.

Suddenly, one Fried Zucchini told me: "Psst, hey kid... you want some
/custom.el/?".  It was a bizarre experience, but armed with my +sword+
*GNU/Emacs* /info/ manual, I started researching this topic.  After a lot of
research (and [[https://www.youtube.com/watch?v=UHk3FbieW0w][Protesilaos Stavrou's enlightening video]] about
~outline-minor-mode~) I, finally, decided to ditch /leaf/ and switched to
/custom/ config with ~outline~ as a structure.  Why ~outline~?  Well, I learned
a good lesson from /use-package/.  Organizing config around packages is a good
idea.  So, I needed something to delimit portions of code and assign them to
different packages.

What a good feeling of freedom it was.  I liked /custom/ because it removed all
the rare-changing variables from /init.el/ and facilitated search and
modification of them.  *GNU/Emacs* GUI is well integrated with keyboard
shortcuts.  It does not require you to use mouse.

Now, it is time to grow up and use /org-mode/.

Every header corresponds to some package name (~package-name~ -> /Package
Name/).  All headers are sorted alphabetically.

*** Abbrev
Good old abbrevs.  One of the oldest packages out there.  This package lets you
define abbreviations for words and can trigger their expansion after inserting a
space.  You can use it just for anything:

- abbreviations (gvt -> government)
- shell aliases (ls -> ls --color=always)
- poor man's spell checker (helol -> hello)
- code templates (fn -> function() {})
- whatever your imagination tells you

You can see a list of my abbrevs [[abbrev_defs][here]].  Of course, I have not defined them all
by myself.  There is a good list of abbrevs [[https://www.emacswiki.org/emacs/autocorrection_abbrev_defs][here]].

#+begin_src elisp
(add-hook 'js-mode-hook 'abbrev-mode)
#+end_src

*** Ansi Color
We still don't have nice things in 2k20.  /Compilation/ mode is still unable to
interprent special sequences by default.  Lets help him.

#+begin_src elisp
(with-eval-after-load 'compile
  (defun colorize-compilation ()
    (let ((inhibit-read-only t))
      (ansi-color-apply-on-region compilation-filter-start (point))))
  (add-hook 'compilation-filter-hook 'colorize-compilation))
#+end_src

*** [[https://github.com/abo-abo/avy][Avy]]
Gotta move fast.  A must-have package to quickly jump to places in a buffer.
Instead of prefixes, I just highlight every /symbol/.  It can be slower with a
lot of short /symbols/ in a buffer, but it works fine most of the time.

#+begin_src elisp
(define-key global-map "\M-z" 'avy-goto-word-0)
(define-key goto-map "\M-g" 'avy-goto-line)
#+end_src

*** Browse Url
Sometimes, I need to browse a url (at point or by inserting it into the
minibuffer).

#+begin_src elisp
(define-key ctl-x-map "B" 'browse-url)
#+end_src

*** [[https://github.com/xFA25E/browse-url-multi][Browse Url Multi]]
My package that enhances default /browse-url/.  It provides a multi-choice
prompt for a url, because, sometimes, I want to open a url through *youtube-dl*,
*mpv* or *transmission*.

#+Begin_src elisp
(define-key mode-specific-map "oy" 'browse-url-multi-youtube-search)
#+end_src

*** [[https://github.com/jwiegley/emacs-async/blob/master/async-bytecomp.el][Bytecomp Async]]
I don't like to wait for byte-compilation.

#+begin_src elisp
(with-eval-after-load 'bytecomp (async-bytecomp-package-mode))
#+end_src

*** [[https://github.com/kwrooijen/cargo.el][Cargo]]
Nice cargo commands, for /state-of-the-art/ experience of *Rust* compilation.

#+begin_src elisp
(add-hook 'rust-mode-hook 'cargo-minor-mode)
#+end_src

*** Comint
In /comint/ we trust.  I like how easy it is to create custom repls with this
package.

#+begin_src elisp
(add-hook 'comint-output-filter-functions 'comint-strip-ctrl-m)
(add-hook 'comint-output-filter-functions 'comint-truncate-buffer)
#+end_src

*** [[https://github.com/minad/consult][Consult]]
This is a game changer.  A package that strives to be a
completion-framework-agnostic replacement for [[https://github.com/abo-abo/swiper][counsel]].

#+begin_src elisp
(define-key global-map "\M-H" 'consult-history)
(define-key goto-map "o" 'consult-outline)
(define-key goto-map "i" 'consult-imenu)
(define-key goto-map "E" 'consult-compile-error)
(define-key goto-map "F" 'consult-flymake)
(define-key project-prefix-map "i" 'consult-project-imenu)
(define-key kmacro-keymap "c" 'consult-kmacro)
#+end_src

*** Css Mode
/Css-mode/ has a good command to lookup documentation.

#+begin_src elisp
(with-eval-after-load 'css-mode (define-key css-mode-map "\C-cm" 'css-lookup-symbol))
#+end_src

*** Custom
By default, /custom/ does not have any keybindings.  This is a shame, since they
are a must-have for it.

#+begin_src elisp
(defvar cus-edit-map (make-sparse-keymap))
(define-key cus-edit-map "v" 'customize-option)
(define-key cus-edit-map "g" 'customize-group)
(define-key cus-edit-map "f" 'customize-face)
(define-key cus-edit-map "s" 'customize-saved)
(define-key cus-edit-map "u" 'customize-unsaved)
(define-key ctl-x-map "c" cus-edit-map)
#+end_src

*** [[https://github.com/xFA25E/cyrillic-dvorak-im][Cyrillic Dvorak Im]]
A package, copied from EmacsWiki (bless them), that provides an input-method for
russian keybord using dvorak.

#+begin_src elisp
(require 'cyrillic-dvorak-im)
#+end_src

*** Dired
Another favorite package of mine.  I can't imagine browsing my file-system
without it anymore.

**** Dired Aux
A package with many useful functions.

#+begin_src elisp
(with-eval-after-load 'dired-aux
  (define-key dired-mode-map "\M-+" 'dired-create-empty-file)
  (add-to-list 'dired-compress-file-suffixes
               (list (rx ".tar.bz2" eos) "" "bunzip2 -dc %i | tar -xf -")))
#+end_src

**** Dired X
Same as the above, but has one of my favorite /dired/ features:
~dired-guess-shell-alist-user~.

#+begin_src elisp
(with-eval-after-load 'dired (require 'dired-x))
#+end_src

**** [[https://github.com/jwiegley/emacs-async/blob/master/dired-async.el][Dired Async]]
Makes a lot of dired commands asyncronous.  Not =delete= though.

#+begin_src elisp
(with-eval-after-load 'dired (dired-async-mode))
#+end_src

*** [[https://github.com/jacktasia/dumb-jump][Dumb Jump]]
Poor man's goto-definition facility.  It uses regexps and *grep/rg/whatever*.

#+begin_src elisp
(add-hook 'xref-backend-functions 'dumb-jump-xref-activate)
#+end_src

*** [[https://github.com/girzel/ebdb][Ebdb]]
An EIEIO port of BBDB (Big Brother DataBase).  Allows you to save contacts.
Also, integrates with MUAs.

#+begin_src elisp
(with-eval-after-load 'ebdb-com
  (define-key ebdb-mode-map "\C-cm" 'ebdb-complete-push-mail-and-quit-window)
  (define-key ebdb-mode-map "\C-cM" 'ebdb-complete-push-mail))

(with-eval-after-load 'message
  (require 'ebdb-message)
  (define-key message-mode-map "\C-ce" 'ebdb-complete))
#+end_src

*** [[https://github.com/Fanael/edit-indirect][Edit Indirect]]
Allows you to edit any region in different /major-mode/.  Very helpful when you
have a file which is a mix of different languages.

#+begin_src elisp
(define-key ctl-x-map "E" 'edit-indirect-region)
#+end_src

*** Elisp Mode
Some macro-expansion commands.

#+begin_src elisp
(define-key emacs-lisp-mode-map "\C-cM" 'emacs-lisp-macroexpand)
(define-key lisp-interaction-mode-map "\C-cM" 'emacs-lisp-macroexpand)
#+end_src

*** Emacs
Here are some options, that can't be changed through /custom/.  Mostly, because
the developers forgot abouth them.  Shame on developers!

#+begin_src elisp
(setq completion-ignore-case t)
#+end_src

*** [[https://github.com/smihica/emmet-mode][Emmet Mode]]
A must-have when you need to write XML by hand.

#+begin_src elisp
(add-hook 'nxml-mode-hook 'emmet-mode)
(add-hook 'mhtml-mode-hook 'emmet-mode)
(add-hook 'web-mode-hook 'emmet-mode)
#+end_src

*** Env
Force programs to disable ansi escape sequences.

#+begin_src elisp
(setenv "PAGER" "cat")
#+end_src

*** Eww
This is a textual web-browser.  It is very useful for browsing "Common Lisp
HyperSpec", "Source Hut" or Youtube (through [[https://invidio.us][Invidious]] instances).  This snippet
lets me use /browse-url-multi/ inside /eww/.

#+begin_src elisp
(with-eval-after-load 'eww
  (defun eww-browse-url-custom ()
    (interactive)
    (let ((browse-url-browser-function (default-value 'browse-url-browser-function)))
      (when-let ((url-at-point (car (eww-links-at-point))))
        (browse-url url-at-point))))
  (define-key eww-mode-map "V" 'eww-browse-url-custom))
#+end_src

*** Find Dired
Another great *GNU/Emacs* feature.  Results of arbitrary *find* commands can be
displayed inside /dired/.

#+begin_src elisp
(define-key search-map "n" 'find-name-dired)
(define-key search-map "N" 'find-dired)
#+end_src

*** Find Func
Usefull commands to jump to /e-lisp/ definitions.

#+begin_src elisp
(define-key ctl-x-map "L" 'find-library)
(define-key ctl-x-map "F" 'find-function)
(define-key ctl-x-map "K" 'find-function-on-key)
(define-key ctl-x-map "V" 'find-variable)
#+end_src

Push xref marker before using some ~find-func~ commands.  By doing this, we can
go back with =M-,=.

#+begin_src elisp
(dolist (fn '(find-library find-function find-function-on-key find-variable))
  (advice-add fn :before 'xref-push-marker-stack-ignore-args))
#+end_src

*** Finder
Show the *Commentary* section of a package.

#+begin_src elisp
(define-key help-map "\M-c" 'finder-commentary)
#+end_src

*** Flymake
On-the-fly linter.

#+begin_src elisp
(with-eval-after-load 'flymake
  (define-key flymake-mode-map "\M-g\M-f" 'flymake-goto-next-error)
  (define-key flymake-mode-map "\M-g\M-b" 'flymake-goto-prev-error))
#+end_src

*** Grep
Another great *GNU/Emacs* package.  You can run arbitatry *grep* commands.
*GNU/Emacs* has an unfortunate bug.  It slows down a lot when displaying too
long lines.  To fix this in /grep/, I define this advice that trims the result
to 500 chars.

#+begin_src elisp
(define-key search-map "g" 'rgrep)
(with-eval-after-load 'grep
  (define-advice grep-expand-template (:filter-return (cmd) add-cut)
    (concat cmd " | cut -c-500")))
#+end_src

*** Hippie Exp
Handy in-buffer completion.  It can use a lot of sources.  Mostly useful to
complete file-name paths.

#+begin_src elisp
(define-key global-map "\C-_" 'hippie-expand)
#+end_src

*** Hl Line
Highlight current line in these modes.

#+begin_src elisp
(add-hook 'csv-mode-hook 'hl-line-mode)
(add-hook 'grep-mode-hook 'hl-line-mode)
(add-hook 'tar-mode-hook 'hl-line-mode)
(add-hook 'transmission-files-mode-hook 'hl-line-mode)
(add-hook 'transmission-mode-hook 'hl-line-mode)
(add-hook 'transmission-peers-mode-hook 'hl-line-mode)
(add-hook 'mpc-mode-hook 'hl-line-mode)
#+end_src

*** Image Dired
Somewhat nice gallery for *GNU/Emacs*.  It's database format is awful because it
uses plain-text.  I rewritten it with a serialized /e-lisp/ data structure.

#+begin_src elisp
(with-eval-after-load 'image-dired
  (load (expand-file-name "emacs/image-dired-db.el" (xdg-config-home))))
#+end_src

*** Ipretty
Pretty-print /e-lisp/ result of last S-EXpression.

#+begin_src elisp
(define-key lisp-interaction-mode-map "\C-j" 'ipretty-last-sexp)
#+end_src

*** Isearch
A great in-buffer search facility.  It is well integrated with ~query-replace~
and ~occur~.

#+begin_src elisp
(define-key isearch-mode-map "\C-h" 'isearch-delete-char)
(define-key isearch-mode-map "\C-?" isearch-help-map)
#+end_src

*** [[https://github.com/ledger/ledger-mode][Ledger Mode]]
Cli, text-based, accounting system.  This particular setting fixes the amount
regex.  By default, it can't recognize amounts with equal sign (~=~) at the
beginning and, as a consequence, can't indent, properly, lines with this kinds
of amounts.

#+begin_src elisp
(with-eval-after-load 'ledger-regex
  (setq ledger-amount-regex
        (concat "\\(  \\|\t\\| \t\\)[ \t]*-?"
                "\\(?:" ledger-commodity-regexp " *\\)?"
                "\\([-=]?\\(?:[0-9]+\\|[0-9,.]+?\\)\\)"
                "\\([,.][0-9)]+\\)?"
                "\\(?: *" ledger-commodity-regexp "\\)?"
                "\\([ \t]*[@={]@?[^\n;]+?\\)?"
                "\\([ \t]+;.+?\\|[ \t]*\\)?$")))
#+end_src

*** [[https://github.com/noctuid/link-hint.el][Link Hint]]
Another favorite package of mine.  It lets you do actions to various points of
interest in buffers using Avy.  It can do anything: buttons, links, completion
candidates.  You name it!

#+begin_src elisp
(define-key goto-map "\M-l" 'link-hint-open-link)
(define-key goto-map "\M-L" 'link-hint-copy-link)
(with-eval-after-load 'link-hint
  (cl-pushnew 'rg-mode (get 'link-hint-compilation-link :vars)))
#+end_src

*** Lisp
#+begin_src elisp
(defun change-pair (change-to)
  (interactive "cChange to:")
  (pcase (assq change-to insert-pair-alist)
    ((or `(,open ,close) `(,_ ,open ,close))
     (save-excursion
       (insert-pair 1 open close)
       (delete-pair)))))

(defun slurp-pair ()
  (interactive)
  (save-excursion
    (backward-up-list)
    (save-excursion
      (pcase (assq (char-after) insert-pair-alist)
        ((or `(,open ,close) `(_ ,open ,close))
         (insert-pair 2 open close)
         (delete-pair))))
    (indent-sexp)))

(define-key global-map "\M-]" 'change-pair)
(define-key global-map "\M-[" 'delete-pair)
(define-key global-map [?\C-\)] 'slurp-pair)
#+end_src

*** Locate
Locate integration.  Unfortunately it is using a simplified (and half-assed)
version of /dired/ to display the results.  It bothers me sometimes.

#+begin_src elisp
(define-key search-map "l" 'locate)
#+end_src

*** [[https://github.com/magit/magit][Magit]]
A killer feature.  Best *git* front-end.

#+begin_src elisp
(define-key project-prefix-map "m" 'magit-project-status)
#+end_src

*** Man
Do you like /smoking/ manuals?

#+begin_src elisp
(define-key help-map "\M-m" 'man)
#+end_src

*** Minibuffer
Some enhancements for default completion-framework.

#+begin_src elisp
(define-key completion-in-region-mode-map "\M-v" 'switch-to-completions)
(define-key minibuffer-local-must-match-map "\C-j" 'minibuffer-force-complete-and-exit)
#+end_src

*** Mpc
Mpc front-end.  It might feel wanky, but that's because it was intended to be
used with ~tool-bar-mode~ enabled.  By giving it some nice keybindings, it
becomes a +butterfly+ nice and usable *mpc* front-end.

#+begin_src elisp
(define-key mode-specific-map "os" 'mpc)
#+end_src

**** Mpc Bindings
Yeah, it does not have default bindings at all!

#+begin_src elisp
(with-eval-after-load 'mpc
  (define-key mpc-mode-map "p" 'mpc-playlist)
  (define-key mpc-mode-map "u" 'mpc-update)
  (define-key mpc-mode-map "a" 'mpc-playlist-add)
  (define-key mpc-mode-map "c" 'mpc-toggle-consume)
  (define-key mpc-mode-map "r" 'mpc-toggle-repeat)
  (define-key mpc-mode-map "." 'mpc-toggle-single)
  (define-key mpc-mode-map "z" 'mpc-toggle-shuffle)
  (define-key mpc-mode-map "t" 'mpc-toggle-play)
  (define-key mpc-mode-map "s" 'mpc-songs-search)
  (define-key mpc-mode-map "k" 'mpc-songs-kill-search)
  (define-key mpc-mode-map "f" 'mpc-ffwd)
  (define-key mpc-mode-map "b" 'mpc-rewind)
  (define-key mpc-mode-map "D" 'mpc-playlist-delete)
  (define-key mpc-mode-map "m" 'mpc-select-toggle)
  (define-key mpc-mode-map "M" 'mpc-select-extend)
  (define-key mpc-mode-map "\M-m" 'mpc-select)
  (define-key mpc-mode-map "\C-m" 'mpc-songs-jump-to)
  (define-key mpc-songs-mode-map [remap mpc-select] nil))
#+end_src

*** Net Utils
Some good net utils, when you need to find out why your pages won't load in your
default web-browser.

#+begin_src elisp
(define-key mode-specific-map "nh" 'nslookup-host)
(define-key mode-specific-map "ni" 'ifconfig)
(define-key mode-specific-map "nn" 'netstat)
(define-key mode-specific-map "np" 'ping)
(define-key mode-specific-map "nw" 'iwconfig)
#+end_src

*** Newsticker
An out-of-the-box rss/atom reader.  It has some bizarre defaults, but it is very
usable.

#+begin_src elisp
(define-key mode-specific-map "on" 'newsticker-show-news)
#+end_src

*** [[https://notmuchmail.org/notmuch-emacs/][Notmuch]]
My main MUA.  The tag system is fantastic.  Switched to it after using /mu4e/
for some years. [[https://www.youtube.com/watch?v=3xWEnAVl1Tw][Thanks!]]

#+begin_src elisp
(define-key mode-specific-map "om" 'notmuch)
(autoload 'notmuch-mua-mail "notmuch-mua")
(define-mail-user-agent 'notmuch-user-agent 'notmuch-mua-mail 'notmuch-mua-send-and-exit 'notmuch-mua-kill-buffer 'notmuch-mua-send-hook)
#+end_src

*** [[https://depp.brause.cc/nov.el/][Nov]]
You can read EPUB in *GNU/Emacs*.

#+begin_src elisp
(add-to-list 'auto-mode-alist (cons (rx ".epub" eos) 'nov-mode))
#+end_src

*** Novice
Some commands in *GNU/Emacs* are disabled by default, because they are thought
to be confusing for novices.  [[https://github.com/xFA25E/images/raw/main/do-nice-things-to-normies.mp4][As one famous philosopher said]].

#+begin_src elisp
(setq disabled-command-function nil)
#+end_src

*** [[https://github.com/zweifisch/ob-http][Ob Http]]
A great http client that uses /Org Mode/.  It does not add itself to
~org-babel-load-languges~ /custom/ type.  Let's help it to be even greater.

#+begin_src elisp
(with-eval-after-load 'org
  (cl-pushnew
   '(const :tag "Http" http)
   (cdadr (memq :key-type (get 'org-babel-load-languages 'custom-type)))
   :test 'equal))
#+end_src

*** Org
Who doesn't know /org-mode/?  This is another killer feature of *GNU/Emacs*.

#+begin_src elisp
(with-eval-after-load 'org
  (define-key org-mode-map [?\C-c?\C-\S-t] 'org-todo-yesterday))
#+end_src

Play a sound after org notification.  I know that one could use
~org-show-notification-handler~, but I'm lazy!

#+begin_src elisp
(define-advice org-show-notification (:after (&rest _) sound)
  (call-process "notify_sound" nil 0 nil))
#+end_src

**** Org Agenda
My tasks, habits etc.

#+begin_src elisp
(define-key mode-specific-map "Ga" 'org-agenda)
(with-eval-after-load 'org-agenda
  (define-key org-agenda-mode-map "T" 'org-agenda-todo-yesterday))
#+end_src

**** Org Capture
This is like enhanced /remember-mode/.

#+begin_src elisp
(define-key mode-specific-map "Gc" 'org-capture)
#+end_src

**** [[https://github.com/org-mime/org-mime][Org Mime]]
Write your e-mail in /org-mode/.

#+begin_src elisp
(autoload 'org-mime-edit-mail-in-org-mode "org-mime" nil t)
(autoload 'org-mime-revert-to-plain-text-mail "org-mime" nil t)
(with-eval-after-load 'message
  (define-key message-mode-map "\C-c\M-o" 'org-mime-htmlize)
  (define-key message-mode-map "\C-c\M-e" 'org-mime-edit-mail-in-org-mode)
  (define-key message-mode-map "\C-c\M-t" 'org-mime-revert-to-plain-text-mail))
#+end_src

*** Paragraphs
Sometimes I need to transpose paragraphs.

#+begin_src elisp
(define-key global-map [?\C-\M-\S-t] 'transpose-paragraphs)
#+end_src

*** [[https://github.com/JonWaltman/pcmpl-args.el][Pcmpl Args]]
e/shell completion facility.  Very great package.  It provides a lot of
completions and a great library for completion definition.

#+begin_src elisp
(autoload 'pcomplete/pass "pcmpl-args")
(autoload 'pcomplete/parted "pcmpl-args")
(with-eval-after-load 'pcmpl-args
  (load (expand-file-name "emacs/pcmpl-args-extra.el" (xdg-config-home))))
#+end_src

*** [[https://github.com/politza/pdf-tools][Pdf Tools]]
Do you like viewing PDFs?

#+begin_src elisp
(pdf-loader-install t t)
#+end_src

*** Pp
Small PP!  Another pretty-printer for /e-lisp/ S-EXpressions.

#+begin_src elisp
(define-key emacs-lisp-mode-map "\C-cm" 'pp-macroexpand-last-sexp)
(define-key lisp-interaction-mode-map "\C-cm" 'pp-macroexpand-last-sexp)
#+end_src

*** Proced
Poor man's *htop*.

#+begin_src elisp
(define-key mode-specific-map "op" 'proced)
#+end_src

*** [[https://github.com/xFA25E/pueue][Pueue]]
A queue of tasks.  Used mostly for downloading youtube videos through
*youtube-dl*.

#+begin_src elisp
(define-key mode-specific-map "ou" 'pueue)
(add-hook 'pueue-mode-hook 'hl-line-mode)
#+end_src

*** Register
Are you familiar with registers?  You can store things!

#+begin_src elisp
(define-key ctl-x-r-map "v" 'view-register)
(define-key ctl-x-r-map "L" 'list-registers)
(define-key ctl-x-r-map "p" 'prepend-to-register)
(define-key ctl-x-r-map "a" 'append-to-register)
#+end_src

*** [[https://github.com/a13/reverse-im.el][Reverse Im]]
It is very difficult to explain what this package does.  Imagine yourself being
a speaker of a language with a cyrillic alphabet.  You would like to write
something in this, bizarre, language and use *GNU/Emacs* bindings at the same
time.  That's what this package does.

#+begin_src elisp
(require 'reverse-im)
(reverse-im-activate "cyrillic-dvorak")
#+end_src

*** [[https://github.com/dajva/rg.el][Rg]]
Super fast *grep*-killer.  In *Rust* we trust.

#+begin_src elisp
(define-key search-map "r" 'rg-menu)
#+end_src

*** [[https://github.com/xFA25E/rx-widget][Rx Widget]]
#+begin_src elisp
(with-eval-after-load 'wid-edit
  (require 'rx-widget)
  (define-widget 'regexp 'rx-widget "A regular expression in rx form."))
#+end_src

*** Savehist
Persistent history in the minibuffer.  This particular setting is used to filter
out: remote files, http links or non-existent files.

#+begin_src elisp
(with-eval-after-load 'savehist
  (defun savehist-filter-file-name-history ()
    (let (result)
      (dolist (file-name file-name-history)
        (let ((f (string-trim-right (expand-file-name file-name) "/+")))
          (unless (string-empty-p f)
            (when (or (file-remote-p f)
                      (string-match-p "\\`http" f)
                      (file-exists-p f))
              (cl-pushnew f result :test #'string-equal)))))
      (setq file-name-history result))))
#+end_src

*** [[https://github.com/manateelazycat/sdcv][SDCV]]
Do you like browsing dictionaries offline inside *GNU/Emacs*?

#+begin_src elisp
(define-key mode-specific-map "ot" 'sdcv-search-input)
#+end_src

*** Sgml Mode
Mode for editing all XML-like languages.

#+begin_src elisp
(with-eval-after-load 'sgml-mode
  (define-key sgml-mode-map "\C-\M-n" 'sgml-skip-tag-forward)
  (define-key sgml-mode-map "\C-\M-p" 'sgml-skip-tag-backward)
  (define-key sgml-mode-map "\C-c\C-r" 'sgml-namify-char))
#+end_src

*** Shell
Plain old shell.  I prefer it to /eshell/ because it uses proper pipes.

#+begin_src elisp
(define-key mode-specific-map "s" 'shell)
#+end_src

*** [[https://github.com/xFA25E/shell-pwd][Shell Pwd]]
Show /shell/ current directory inside mode-line.

#+begin_src elisp
(define-key mode-specific-map "l" 'shell-pwd-list-buffers)
(with-eval-after-load 'shell
  (define-key shell-mode-map "\C-c\M-d" 'shell-pwd-change-directory))
#+end_src

*** Simple
Some useful *GNU/Emacs* commands not bound by default (for some unknown reason).

#+begin_src elisp
(defun kill-region-dwim (&optional count)
  (interactive "p")
  (if (use-region-p)
      (kill-region (region-beginning) (region-end))
    (backward-kill-word count)))

(define-key global-map "\C-h" 'backward-delete-char-untabify)
(define-key global-map "\M-K" 'kill-whole-line)
(define-key global-map "\M-c" 'capitalize-dwim)
(define-key global-map "\M-l" 'downcase-dwim)
(define-key global-map "\M-u" 'upcase-dwim)
(define-key global-map "\C-w" 'kill-region-dwim)
(define-key mode-specific-map "oP" 'list-processes)
#+end_src

*** Skeleton
The *GNU/Emacs*'s standard templates.  I use ~C-h~ to delete backwards a
character.  /Skeleton/ has an annoying feature: it displays help by default on
~C-h~, even if ~help~ symbol is not bound.  The only reliable way to disable
this is by an override advice.

#+begin_src elisp
(define-advice skeleton-read (:override (prompt &optional initial-input recursive) no-help)
  (let ((minibuffer-help-form (when (boundp 'help) (symbol-value 'help)))
        (eolp (eolp)))
    (unless eolp (save-excursion (insert "\n")))
    (unwind-protect
        (setq prompt (cond ((stringp prompt)
                            (read-string (format prompt skeleton-subprompt)
                                         (setq initial-input (or initial-input (symbol-value 'input)))))
                           ((functionp prompt) (funcall prompt))
                           (t (eval prompt))))
      (unless eolp (delete-char 1))))
  (if (and recursive (or (null prompt) (string= prompt "")))
      (signal 'quit t)
    prompt))
#+end_src

*** [[https://github.com/xFA25E/skempo][Skempo]]
Enhance default *GNU/Emacs* templates.  I don't like Yasnippet, so I wrote a
package that fixes problems of /tempo/ and /skeleton/.

#+begin_src elisp
(add-hook 'nix-mode-hook 'skempo-mode)
(add-hook 'js-mode-hook 'skempo-mode)
(autoload 'skeleton-template-lisp-defpackage "skempo")
(autoload 'skeleton-template-lisp-defsystem "skempo")
(with-eval-after-load 'skempo
  (define-key skempo-mode-map "\C-z" 'skempo-complete-tag-or-call-on-region)
  (define-key skempo-mode-map "\M-g\M-e" 'skempo-forward-mark)
  (define-key skempo-mode-map "\M-g\M-a" 'skempo-backward-mark)
  (load (expand-file-name "emacs/skempo-templates.el" (xdg-config-home))))
#+end_src

*** [[https://github.com/joaotavora/sly][Sly]]
Author of the best *Common Lisp* IDE doesn't know how to use ~defcustom~.  I
send him a patch, but he ignores me.

#+begin_src elisp
(with-eval-after-load 'sly
  (setq sly-lisp-implementations
        '((sbcl  ("sbcl"))
          (ecl   ("ecl"))
          (ccl   ("ccl"))
          (clisp ("clisp"))
          (abcl  ("abcl")))))
#+end_src

*** Subword
Consider ~SubWord~ as two separate words.  Useful for camel-case languages.

#+begin_src elisp
(add-hook 'rust-mode-hook 'subword-mode)
(add-hook 'nix-mode-hook 'subword-mode)
(add-hook 'js-mode-hook 'subword-mode)
#+end_src

*** Tex Mode
Small settings for /tex-mode/ and /ispell/.  Never used it :/

#+begin_src elisp
(add-hook 'tex-mode-hook (lambda nil (setq-local ispell-parser 'tex)))
#+end_src

*** [[https://github.com/holomorph/transmission][Transmission]]
Do you like downloading torrents?

#+begin_src elisp
(define-key mode-specific-map "or" 'transmission)

(with-eval-after-load 'transmission
  (define-key transmission-mode-map "M" 'transmission-move)
  (define-key transmission-files-mode-map "R" 'transmission-files-rename-path)

  (defun transmission-files-rename-path (torrent-id old-path new-name)
    "Rename an OLD-PATH to NEW-NAME of TORRENT-ID.

TORRENT-ID is a hashString of torrent.

OLD-PATH is a path to file in a torrent.  It can be a directory
or a file.

NEW-NAME is a new name of a file at OLD-PATH.

When called interactively, values are taken from current buffer
with `transmission-files-mode'.  OLD-PATH can be set explicitly
with prefix argument, otherwise the file at point is taken.

Note: it is forbidden to move a file to other locations, only
renaming is allowed."
    (interactive
     (let* ((old-path (cdr (assq 'name (tabulated-list-get-id))))
            (old-path-prompt (format "Old path (default %s): " old-path))
            (old-path (if current-prefix-arg
                          (read-string old-path-prompt nil nil old-path)
                        old-path))
            (new-name (file-name-nondirectory old-path))
            (new-name-prompt (format "Rename %s to: " new-name))
            (new-name (read-string new-name-prompt nil nil new-name)))
       (list transmission-torrent-id old-path new-name)))

    (when (string= new-name (file-name-nondirectory old-path))
      (user-error "Cannot rename to the same name: %s" new-name))

    (let ((arguments (list :ids (list torrent-id) :path old-path :name new-name)))
      (transmission-request-async nil "torrent-rename-path" arguments))))
#+end_src

*** Url Parse
This is a *GREAT POSOS* (from rus: posos -> sosat -> сосать -> to suck), as I
like to call it.  Because /url-parse/ doesn't protect ~match-data~, it fucks up
~url-handler-mode~ and, as a result, fucks up /org-mime/ too.

#+begin_src elisp
(with-eval-after-load 'url-parse
  (define-advice url-generic-parse-url (:around (fn &rest args) save-match-data)
    (save-match-data (apply fn args))))
#+end_src

*** [[https://github.com/fxbois/web-mode][Web Mode]]
You can edit files with a lot of different web languages in it.

#+begin_src elisp
(add-to-list 'auto-mode-alist (cons (rx ".twig" eos) 'web-mode))
#+end_src

*** Window
Do you like windows?  Me neither.

#+begin_src elisp
(define-key global-map "\M-V" 'scroll-down-line)
(define-key global-map [?\C-\S-v] 'scroll-up-line)
(define-key global-map [?\C-\M-\S-b] 'previous-buffer)
(define-key global-map [?\C-\M-\S-f] 'next-buffer)
(define-key global-map "\M-Q" 'quit-window)
(define-key global-map "\M-o" 'other-window)
#+end_src

*** Xref
Built-in general facility for finding and referencing definitions.  Here, a
function is defined that saves current place to xref stack, but it ignores it's
arguments.  It is used mostly in advices and hooks.

#+begin_src elisp
(autoload 'xref-push-marker-stack "xref")
(defun xref-push-marker-stack-ignore-args (&rest _)
  (xref-push-marker-stack))
#+end_src

** Load Custom
Finally, I load [[custom.el]] settings.

#+begin_src elisp
(load (expand-file-name "nixpkgs/emacs/custom.el" (xdg-config-home)) nil nil t)
#+end_src

* Templates
*GNU/Emacs* can do templates out of the box!

** Skempo
:properties:
:header-args:elisp: :tangle skempo-templates.el
:end:

Header with imports.

#+begin_src elisp
;; -*- lexical-binding: t; -*-
(require 'skempo)
#+end_src

*** User Elements
/Tempo/ is very extensible (there is a similar feature for /skeleton/).  Here, I
define a function that processes unknown elements to /tempo/ and returns other
/tempo/ elements.  Very easy.

The most tricky part is in ~lisp-with-parens~.  It surrounds a /tempo/ template
with parens, when it detects that there were no open or close parens.  It is
used mostly in lisp abbrevs, because a template has to expand correctly in all
of three situations:

- ~word SPC~
- ~(word SPC~
- ~word SPC)~

#+begin_src elisp
(defun skempo-user-element (arg)
  (pcase arg
    ('nix-hash (make-string 52 ?1))
    ('elisp-namespace (string-trim-right (buffer-name) (rx ".el" eos)))
    ('elisp-group (string-trim-right (buffer-name) (rx (? "-mode") ".el" eos)))
    ('delete-parens
     (when (and (eql (char-before) ?\() (eql (char-after) ?\)) (not (use-region-p)))
       (delete-char -1)
       (delete-char 1))
     '(l nil))))

(add-to-list 'tempo-user-elements 'skempo-user-element)

(defun skempo-lisp-mode-further-elements ()
  (setq skeleton-further-elements
        '((delete-parens ''(when (and (eql (char-before) ?\()
                                      (eql (char-after) ?\))
                                      (not (use-region-p)))
                             (delete-char -1)
                             (delete-char 1))))))

(with-eval-after-load 'lisp-mode
  (add-hook 'lisp-mode-hook 'skempo-lisp-mode-further-elements))

#+end_src

*** Lisp templates
Templates used in /lisp-mode/ and /emacs-lisp-mode/.

#+begin_src elisp
(skempo-define-tempo (lambda :mode (emacs-lisp-mode lisp-mode))
  delete-parens
  "(lambda (" p ") " r> ")")

(skempo-define-tempo (let :mode (emacs-lisp-mode lisp-mode))
  delete-parens
  "(let ((" p "))" n>
  r> ")")
#+end_src

**** Common Lisp
#+begin_src elisp
(skempo-define-tempo (defvar :mode lisp-mode)
  delete-parens
  "(defvar " p n>
  r> n>
  "\"" p "\")")

(skempo-define-tempo (defun :mode lisp-mode)
  delete-parens
  "(defun " p " (" p ")" n>
  "\"" p "\"" n>
  r> ")")

(skempo-define-skeleton (defpackage :mode lisp-mode)
  "Package name: " delete-parens
  "(defpackage #:" str > "\n"
  "(:use #:cl)" > "\n"
  "(:nicknames" ("Nickname: " " #:" str) & ")" | -12 > "\n"
  "(:local-nicknames" ("Local nickname: " " (#:" str " #:" (skeleton-read "Nickname of package: " nil t) ")") & ")" | -18 > "\n"
  ("Import from: " "(:import-from #:" str ("Import: " " #:" str) ")" > "\n")
  "(:export" ("Export: " " #:" str) & ")" | -9 > "\n"
  "(:documentation \"" (skeleton-read "Documentation: ") "\"))" > "\n"
  "(in-package #:" str ")" > "\n")

(skempo-define-skeleton (defsystem :mode lisp-mode)
  "System name: " delete-parens
  "(defsystem \"" str "\"" > "\n"
  ":long-name \"" (skeleton-read "Long name: ") "\"" | -13 > "\n"
  ":version \"" (skeleton-read "Version: " "0.0.1") & "\"" | -11 > "\n"
  ":author \"" (setq v1 (skeleton-read "Author: ")) & "\"" | -10 > "\n"
  ":maintainer \"" (skeleton-read "Maintainer: " v1) & "\"" | -14 > "\n"
  ":license \"" (skeleton-read "License: " "GPL3") & "\"" | -11 > "\n"
  ":homepage \"" (setq v2 (skeleton-read "Homepage: ")) & "\"" | -12 > "\n"
  ":bug-tracker \"" (skeleton-read "Bug tracker: " (when (and v2 (not (string-empty-p v2))) (concat v2 "/issues"))) & "\"" | -15 > "\n"
  ":description \"" (skeleton-read "Description: ") "\"" > "\n"
  ":mailto \"" (skeleton-read "Mailto: " (string-trim-right (string-trim-left (or v1 "") ".*?<") ">")) & "\"" | -10 > "\n"
  (nil ":source-control (:" (skeleton-read "Source control: " "git" t) " \"" (skeleton-read "Link: " (when (and v2 (not (string-empty-p v2))) (concat v2 ".git")) t) "\")" > "\n")
  ":long-description #.(let ((file (probe-file* (subpathname *load-pathname* \"README.md\")))) (when file (read-file-string file)))" > "\n"
  ":depends-on (" ("Dependency: " "\"" str "\" ") & -1 & ")" | -14 > "\n"
  ":components ((:module \"src\" :components ((:file \"" str "\"))))" > "\n"
  ":in-order-to ((test-op (test-op \"" str "/tests\")))" > "\n"
  -1 ")" "\n"
  "\n"
  "(defsystem \"" str "/tests\"" > "\n"
  ":depends-on (\"" str "\" \"fiveam\")" > "\n"
  ":components ((:module \"tests\" :components ((:file \"" str "\"))))" > "\n"
  ":perform (test-op (op c) (symbol-call '#:fiveam '#:run! (find-symbol* '#:" str " '#:" str ".tests)))" > "\n"
  -1 ")")
#+end_src

**** Emacs Lisp
They are different from Common Lisp, because I want every e-lisp symbol to be
prefixed with buffer name.

#+begin_src elisp
(skempo-define-tempo (defvar :mode emacs-lisp-mode)
  delete-parens
  "(defvar " elisp-namespace "-" p n>
  r> n>
  "\"" p "\")")

(skempo-define-tempo (defun :mode emacs-lisp-mode)
  delete-parens
  "(defun " elisp-namespace "-" p " (" p ")" n>
  "\"" p "\"" n>
  r> ")")

(skempo-define-tempo (defgroup :mode emacs-lisp-mode)
  delete-parens
  "(defgroup " elisp-group " nil" n>
  "\"" p "\"" n>
  ":group " p "nil)")

(skempo-define-tempo (defcustom :mode emacs-lisp-mode)
  delete-parens
  "(defcustom " elisp-namespace "-" p n>
  r> n>
  "\"" p "\"" n>
  ":type " p "nil" n>
  ":group '" elisp-group ")")

(skempo-define-tempo (defface :mode emacs-lisp-mode)
  delete-parens
  "(defface " elisp-namespace "-" p n>
  "'((t :inherit " p "nil))" n>
  "\"" p "\"" n>
  ":group '" elisp-group ")")
#+end_src

*** Js
The power of /skeleton/ iterative templates.  It can insert multiple /case/
statements.

#+begin_src elisp
(skempo-define-skeleton (switch :mode js-mode)
  "Expression: "
  "switch (" str ") {" > \n
  ("Pattern: "
   "case " str ":" > \n
   @ \n
   "break;" > \n \n)
  "default:" > \n
  @ \n
  "}" >)

(skempo-define-tempo (function :mode js-mode)
  "function " p "(" p ") {" n>
  p n>
  "}" >)

(skempo-define-tempo (if :mode js-mode)
  "if (" p ") {" n>
  p n>
  "}" >)

(skempo-define-tempo (for :mode js-mode)
  "for (" p ") {" n>
  p n>
  "}" >)

(skempo-define-tempo (try :mode js-mode)
  "try {" n>
  p n>
  "} catch (" p "error) {" > n>
  p n>
  "}" >)
#+end_src

*** Nix
Very useful nix templates.

#+begin_src elisp
(skempo-define-tempo (github :mode nix-mode)
  "fetchFromGitHub {" n>
  "owner = \"" p "\";" n>
  "repo = \"" p "\";" n>
  "rev = \"" p "\";" n>
  "sha256 = \"" p nix-hash "\";" n>
  "}" p >)

(skempo-define-tempo (url :mode nix-mode)
  "fetchurl {" n>
  "url = \"" p "\";" n>
  "sha256 = \"" p nix-hash "\";" n>
  "}" p >)

(skempo-define-tempo (zip :mode nix-mode)
  "fetchzip {" n>
  "url = \"" p "\";" n>
  "sha256 = \"" p nix-hash "\";" n>
  "}" p >)

(skempo-define-tempo (git :mode nix-mode)
  "fetchgit {" n>
  "url = \"" p "\";" n>
  "rev = \"" p "\";" n>
  "sha256 = \"" p nix-hash "\";" n>
  "}" p >)
#+end_src

*** Php
#+begin_src elisp
(skempo-define-tempo (vd :mode php-mode)
  "echo '<pre>'; var_dump(" r "); echo '</pre>';")
#+end_src

*** Org
#+begin_src elisp
(skempo-define-tempo (readmeorg :mode org-mode)
  "#+TITLE: " (P "Project title: ") n
  (P "A short, one-line description of the project: ") n
  n
  "* Overview" n
  p "# A longer description of the project" n
  n
  "** Features" n
  "** History" n
  "** Motivation" n
  "* Usage" n
  p "# Examples of usage" n
  n
  "* Documentation" n
  "* License" n
  "Copyright (c) " (format-time-string "%Y") " " (P "Authors: ") n
  "Licensed under the " p "GPL3 License." n
  n
  "* COMMENT Local Variables" n
  "# Local Variables:" n
  "# eval: (add-hook 'after-save-hook #'org-md-export-to-markdown nil t)" p n
  "# End:")
#+end_src

** Auto Insert
:PROPERTIES:
:header-args: :mkdirp yes
:END:

Auto Insert supports files as templates if you give it a directory.

*** Nix Shell
Let's write some reproducible /nix-shell/ templates.

**** Emacs Lisp
This ~shell.nix~ file will configure an environment with [[https://github.com/doublep/eldev][Eldev]].  I use it mostly
for great linters via ~eldev lint~ command.  All eldev directories will be local
to the project directory.

#+begin_src nix :tangle auto-insert/shell-emacs-lisp.nix
let
  pkgs = import <nixpkgs> {};
  eldev = pkgs.stdenv.mkDerivation rec {
    pname = "eldev";
    version = "0.9.3";
    src = pkgs.fetchurl {
      url = "https://raw.githubusercontent.com/doublep/eldev/${version}/bin/eldev";
      sha256 = "0ikhhfxm1rz3wp37spsy8bcnx5071ard71pd1riw09rsybilxhgn";
    };
    nativeBuildInputs = [ pkgs.makeWrapper ];
    unpackPhase = "true";
    installPhase = ''
      install -D -v -m555 "$src" "$out/bin/eldev"
      wrapProgram "$out/bin/eldev" --set ELDEV_EMACS "${pkgs.emacs}/bin/emacs"
    '';
  };
in pkgs.mkShell {
  buildInputs = [ eldev ];
  ELDEV_DIR = "${builtins.toString ./.}/.eldev";
}
#+end_src

**** Common Lisp
This ~shell.nix~ configures local environment *Common Lisp*.  It automaticall
downloads quicklisp in project local directory and patches various
implementations to use it by default.

#+begin_src nix :tangle auto-insert/shell-common-lisp.nix
let
  pkgs = import <nixpkgs> {};

  PROJECT_ROOT = builtins.toString ./.;
  QUICKLISP_DIR = "${PROJECT_ROOT}/.quicklisp";

  quicklisp-lisp = builtins.fetchurl https://beta.quicklisp.org/quicklisp.lisp;
  quickstart = pkgs.writeShellScriptBin "quickstart" ''
    ${pkgs.sbcl}/bin/sbcl \
        --non-interactive \
        --no-userinit \
        --load "${quicklisp-lisp}" \
        --eval "(quicklisp-quickstart:install :path #P\"${QUICKLISP_DIR}/\")"
  '';

  init-lisp = pkgs.writeText "init.lisp" ''
    #-quicklisp
    (let ((quicklisp-init #P"${QUICKLISP_DIR}/setup.lisp"))
      (when (probe-file quicklisp-init)
        (load quicklisp-init)))
  '';

  make-implementation = name: pkg: flags: pkgs.symlinkJoin {
    name = name;
    paths = [ pkg ];
    nativeBuildInputs = [ pkgs.makeWrapper ];
    postBuild = ''
      wrapProgram $out/bin/${name} --add-flags '${flags}'
    '';
  };

  sbcl = make-implementation "sbcl" pkgs.sbcl "--userinit ${init-lisp}";
  ecl = make-implementation "ecl" pkgs.ecl "--norc --load ${init-lisp}";
  ccl = make-implementation "ccl" pkgs.ccl "--no-init --load ${init-lisp}";
  clisp = make-implementation "clisp" pkgs.clisp "-norc -i ${init-lisp}";
  abcl = make-implementation "abcl" pkgs.abcl "--noinit --load ${init-lisp}";

in pkgs.mkShell {
  CL_SOURCE_REGISTRY="${PROJECT_ROOT}:";
  ASDF_OUTPUT_TRANSLATIONS = ''
    (:output-translations
     :ignore-inherited-configuration
     (t ("${PROJECT_ROOT}" ".common-lisp" :implementation)))
  '';
  buildInputs =  [ quickstart sbcl ecl ccl clisp abcl ];
  shellHook = ''
    [ -d "${QUICKLISP_DIR}" ] || quickstart
  '';
}
#+end_src

*** Gitignore

**** Common Lisp
#+begin_src text :tangle auto-insert/gitignore-common-lisp
*.fasl
*.dx32fsl
*.dx64fsl
*.lx32fsl
*.lx64fsl
*.x86f
*~
.#*
.quicklisp
.common-lisp
#+end_src

**** Emacs Lisp
#+begin_src text :tangle auto-insert/gitignore-emacs-lisp
*.elc
.eldev
#+end_src
